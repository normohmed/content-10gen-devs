<course url_name='2012_Fall' org='10gen' course='M101' start='2012-10-22T00:00' display_name='MongoDB for Developers'><chapter graceperiod='1 day' start='2012-10-22T00:00' due='2012-10-31T03:00' display_name='Week 1'><sequential graded='false' format='Quiz' display_name='Welcome to M101'><vertical><video display_name='Lecture' youtube='1.0:179MiZSibco'/></vertical><problem showanswer='attempted' url_name='Welcome_to_M101_problem' rerandomize='never' display_name='Quiz'>What counts toward your final grade in the class?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>Quizzes<endouttext/></choice><choice correct='true'><startouttext/>Homeworks<endouttext/></choice><choice correct='true'><startouttext/>Final Exam<endouttext/></choice><choice correct='false'><startouttext/>Class Participation<endouttext/></choice></checkboxgroup></choiceresponse></problem></sequential><sequential graded='false' format='Quiz' display_name='What is MongoDB?'><vertical><video display_name='Lecture' youtube='1.0:Lfl8hdQOi6Y'/></vertical><problem showanswer='attempted' url_name='What_is_MongoDB__problem' rerandomize='never' display_name='Quiz'>Which of the following statements are true about MongoDB?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>MongoDB is document oriented.<endouttext/></choice><choice correct='false'><startouttext/>MongoDB supports Joins.<endouttext/></choice><choice correct='true'><startouttext/>MongoDB is schemaless<endouttext/></choice><choice correct='false'><startouttext/>MongoDB supports SQL.<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:h80NwJJZM-g'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Mongo Relative to Relational'><vertical><video display_name='Lecture' youtube='1.0:-KIC1LXxcGM'/></vertical><problem showanswer='attempted' url_name='Mongo_Relative_to_Relational_problem' rerandomize='never' display_name='Quiz'>Which features did MongoDB omit in order to retain scalability?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>Joins<endouttext/></choice><choice correct='false'><startouttext/>Indexes<endouttext/></choice><choice correct='false'><startouttext/>Secondary Indexes<endouttext/></choice><choice correct='true'><startouttext/>Transactions across multiple collections<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:IAvnMgvHuLw'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Overview of Building an app with Mongo'><vertical><video display_name='Lecture' youtube='1.0:_e0J06elxb8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Quick Introduction to the Mongo Shell'><vertical><video display_name='Lecture' youtube='1.0:f-lyGAMnNY4'/></vertical><problem showanswer='attempted' url_name='Quick_Introduction_to_the_Mongo_Shell_problem' rerandomize='never' display_name='Quiz'>Which of the following expressions are valid JSON documents?
<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>{a:1, b:2, c:3}<endouttext/></choice><choice correct='false'><startouttext/>{a,1; b,4, c,6}<endouttext/></choice><choice correct='false'><startouttext/>{a:1; b:1; c:4}<endouttext/></choice><choice correct='false'><startouttext/>(A,1; b:2; c,4}<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:YQTqdLe3W4M'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON introduced'><vertical><video display_name='Lecture' youtube='1.0:2jsJeH8q6YM'/></vertical><problem showanswer='attempted' url_name='JSON_introduced_problem' rerandomize='never' display_name='Quiz'>Which of the following are valid JSON documents?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>{a:1, b:2, c: 3}<endouttext/></choice><choice correct='true'><startouttext/>{a:1, b:2, c:[1,2,3,4,5]}<endouttext/></choice><choice correct='true'><startouttext/>{a:1, b:{}, c: [ { a:1, b:2}, 5, 6]}<endouttext/></choice><choice correct='true'><startouttext/>{  }<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:uWcOsdV4Iz4'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing MongoDB (mac)'><vertical><video display_name='Lecture' youtube='1.0:6VFukRETCTg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing MongoDB (windows)'><vertical><video display_name='Lecture' youtube='1.0:hX5louVryOQ'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing Bottle and Python (mac)'><vertical><video display_name='Lecture' youtube='1.0:vxTN6KFegLg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing Python (windows)'><vertical><video display_name='Lecture' youtube='1.0:njfPdZTmTrI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing Bottle.py (windows)'><vertical><video display_name='Lecture' youtube='1.0:OhEpXjL0vt8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing PyMongo (mac)'><vertical><video display_name='Lecture' youtube='1.0:XRJawbpWxtg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Installing PyMongo (windows)'><vertical><video display_name='Lecture' youtube='1.0:YwWc6HZ0LWo'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Hello World, Mongo Style'><vertical><video display_name='Lecture' youtube='1.0:IG7PntLyv2E'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Hello World on a Web Server'><vertical><video display_name='Lecture' youtube='1.0:8_o6nyenZbk'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Mongo is Schemaless'><vertical><video display_name='Lecture' youtube='1.0:K6dlBbH_XHI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Revisited'><vertical><video display_name='Lecture' youtube='1.0:zbYCcMWJGNY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Arrays'><vertical><video display_name='Lecture' youtube='1.0:JkK9n6_ahVk'/></vertical><problem showanswer='attempted' url_name='JSON_Arrays_problem' rerandomize='never' display_name='Quiz'>Write the JSON for a simple document containing a single key "fruit" that has as its value an array containing three strings: "apple", "pear", and "peach"<customresponse><textbox rows='4' cols='50' correct_answer="{'fruit': ['apple', 'pear', 'peach']}"/><answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{'fruit': ['apple', 'pear', 'peach']}'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:ciuq7XPqHKI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Subdocuments'><vertical><video display_name='Lecture' youtube='1.0:vrYAEH3g13M'/></vertical><problem showanswer='attempted' url_name='JSON_Subdocuments_problem' rerandomize='never' display_name='Quiz'>Write a JSON document with a single key, "address" that has as it value another document with the keys 
'street_address', 'city', 'state', 'zipcode', with the following values: 'street_address' is "23 Elm Drive", 'city' is "Palo Alto", 'state' is "California", 'zipcode' is "94305"<customresponse><textbox rows='4' cols='50' correct_answer="{'address': {'street_address': &quot;23 Elm Drive&quot;, 'city' : &quot;Palo Alto&quot;, 'state': &quot;California&quot;, 'zipcode': &quot;94305&quot;} }"/><answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{'address': {'street_address': "23 Elm Drive", 'city' : "Palo Alto", 'state': "California", 'zipcode': "94305"} }'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:NGp_y6BaEMw'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='JSON Spec'><vertical><video display_name='Lecture' youtube='1.0:kOrsT94-A28'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Introduction to our class project, the blog'><vertical><video display_name='Lecture' youtube='1.0:ePi3kDoexoM'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Blog in Relational Tables'><vertical><video display_name='Lecture' youtube='1.0:boR2y9MHCa0'/></vertical><problem showanswer='attempted' url_name='Blog_in_Relational_Tables_problem' rerandomize='never' display_name='Quiz'>letâ€™s assume that our blog can be modeled with the following relational tables:

<pre>
authors:
	author_id,
	name,
	email,
	password

posts:
	post_id,
	author_id
	title,
	body,	
	publication_date

comments:
	comment_id,
	name, 
	email,
	comment_text

post_comments:
	post_id,
	comment_id


tags
	tag_id
	name

post_tags
	post_id
	tag_id
</pre>

In order to display a blog post with its comments and tags, how many tables will need to be accessed?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>2</text></choice><choice location='bottom' correct='false'><text>3</text></choice><choice location='bottom' correct='false'><text>5</text></choice><choice location='bottom' correct='true'><text>6</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:vB-4AbbLKeg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Blog in Documents'><vertical><video display_name='Lecture' youtube='1.0:ZjwCzyqKVdY'/></vertical><problem showanswer='attempted' url_name='Blog_in_Documents_problem' rerandomize='never' display_name='Quiz'>Given the document schema that we proposed for the blog, how many collections would we need to access to display the blog home page?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>0</text></choice><choice location='bottom' correct='true'><text>1</text></choice><choice location='bottom' correct='false'><text>2</text></choice><choice location='bottom' correct='false'><text>4</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:WJblHPsp1p4'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Intro to Schema Design'><vertical><video display_name='Lecture' youtube='1.0:6XE3wZCPiZ8'/></vertical><problem showanswer='attempted' url_name='Intro_to_Schema_Design_problem' rerandomize='never' display_name='Quiz'>In which scenario is it impossible to embed data within a document (you must put the data in it a separate collection). Check all that apply.<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>The data would be duplicated across multiple objects within a collection.<endouttext/></choice><choice correct='false'><startouttext/>You need an index on the data element.<endouttext/></choice><choice correct='true'><startouttext/>The embedded data could exceed the 16MB document limit within MongoDB<endouttext/></choice><choice correct='false'><startouttext/>The data is not isomorphic.<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:wiwOEG_6ojs'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Intro to Python'><vertical><video display_name='Lecture' youtube='1.0:-cAtffa59FM'/></vertical><problem showanswer='attempted' url_name='Intro_to_Python_problem' rerandomize='never' display_name='Quiz'>Write an expression to concatenate two strings "hat" and "pin" in python to the string "hatpin"<customresponse><textbox rows='4' cols='50' correct_answer='"hat" + "pin"'/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''"hat" + "pin"'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:PuyAdxxzSk0'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python Lists'><vertical><video display_name='Lecture' youtube='1.0:H1BOYfbnPq8'/></vertical><problem showanswer='attempted' url_name='Python_Lists_problem' rerandomize='never' display_name='Quiz'>Write the to code to initialize a list with the items "hammer", "nail" and "wall" and assign the list to the variable named "things".<customresponse><textbox rows='4' cols='50' correct_answer='things = ["hammer", "nail", "wall"]'/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things = ["hammer", "nail", "wall"]'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:8WdnrhlfSLE'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python Lists, Manipulating'><vertical><video display_name='Lecture' youtube='1.0:PHii2QYNyB8'/></vertical><problem showanswer='attempted' url_name='Python_Lists_Manipulating_problem' rerandomize='never' display_name='Quiz'>Write the code to append the item "hammer" onto a list named things.

<p>Please use double quotes at this time.</p><customresponse><textbox rows='4' cols='50' correct_answer='things.append("hammer")'/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things.append("hammer")'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:ZSraFzkEDzs'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python Lists, Slice Operator'><vertical><video display_name='Lecture' youtube='1.0:vNyIZNWK0rw'/></vertical><problem showanswer='attempted' url_name='Python_Lists_Slice_Operator_problem' rerandomize='never' display_name='Quiz'>things = ['apples', 'orange', 'pear', 'grape', 'kiwi']. What is the slice notation that will return the sublist ['orange', 'pear']?
<customresponse><textbox rows='4' cols='50' correct_answer="things[1:3]"/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things[1:3]'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:vE498xAFoGc'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python Lists, Inclusion'><vertical><video display_name='Lecture' youtube='1.0:QXUMUvHB2Ws'/></vertical><problem showanswer='attempted' url_name='Python_Lists_Inclusion_problem' rerandomize='never' display_name='Quiz'>given a python list called "fruit", write an if statement to check whether "apple" is in the list.

<p>Please use double quotes at this time.</p><customresponse><textbox rows='4' cols='50' correct_answer='if "apple" in fruit:&#10;'/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''if "apple" in fruit:
'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:LdA0__D4zLI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python, Working with Dicts'><vertical><video display_name='Lecture' youtube='1.0:_AbCyE0uKmE'/></vertical><problem showanswer='attempted' url_name='Python_Working_with_Dicts_problem' rerandomize='never' display_name='Quiz'>Initialize a new dict named "colors" with the following key values pairs: sky is blue, sea is blue. earth is brown.

<i>Note:  Please preserve the order of these keys when you enter your answer.</i><customresponse><textbox rows='4' cols='50' correct_answer="colors = {'sky': 'blue', 'sea' : 'blue', 'earth': 'brown'}"/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''colors = {'sky': 'blue', 'sea' : 'blue', 'earth': 'brown'}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:edEYrBoa7Ao'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: Dicts and Lists together'><vertical><video display_name='Lecture' youtube='1.0:9k1XvuoGdrk'/></vertical><problem showanswer='attempted' url_name='Python_Dicts_and_Lists_together_problem' rerandomize='never' display_name='Quiz'>Initialize a new dict with a single key, "animals" whose value is the list "dog", "cat", "zebra" and assign the entire expression to variable named "things"<customresponse><textbox rows='4' cols='50' correct_answer="things = {'animals' : ['dog', 'cat', 'zebra']}"/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things = {'animals' : ['dog', 'cat', 'zebra']}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:Gqb-OUFcQas'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: for loops, with Lists'><vertical><video display_name='Lecture' youtube='1.0:zMqLCtf3ML4'/></vertical><problem showanswer='attempted' url_name='Python_for_loops_with_Lists_problem' rerandomize='never' display_name='Quiz'>What does the following code print?

<pre>
sum = 0
numbers = [1,2,3,5,8]
for i in numbers:
  sum = sum + i
print i
</pre><customresponse><textbox rows='4' cols='50' correct_answer="8"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''8'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:ohA78_D5Rn8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: for loops with dicts'><vertical><video display_name='Lecture' youtube='1.0:HHTICY6rUGI'/></vertical><problem showanswer='attempted' url_name='Python_for_loops_with_dicts_problem' rerandomize='never' display_name='Quiz'><pre>
people = {'name':'Bob', 'hometown': "Palo Alto", 'favorite_color': 'red'}
for item in people:
  if (item == 'favorite_color'):
     print  people[item]
</pre>

What does this program print?<customresponse><textbox rows='4' cols='50' correct_answer="red"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''red'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:OnkPdMP1fVc'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: Combining Dicts and Lists'><vertical><video display_name='Lecture' youtube='1.0:ome7jDN_lH0'/></vertical><problem showanswer='attempted' url_name='Python_Combining_Dicts_and_Lists_problem' rerandomize='never' display_name='Quiz'>
<pre>
obj = {'a':1,'b': 2, 'c': [1, 3, 5]}

sum = 0
if 'c' in obj:
   for n in obj['c']:
     sum = sum + n

print sum
</pre>
     <customresponse><textbox rows='4' cols='50' correct_answer="9"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''9'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:Y6NKd6xUC6M'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: while loops'><vertical><video display_name='Lecture' youtube='1.0:TEdFAheS5UE'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: function calls'><vertical><video display_name='Lecture' youtube='1.0:PizwcirYuGY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Python: exception handling'><vertical><video display_name='Lecture' youtube='1.0:nrZYqF9KwaU'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Bottle framework: Url Handlers'><vertical><video display_name='Lecture' youtube='1.0:x5TlvbWxjL0'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Bottle framework: using views'><vertical><video display_name='Lecture' youtube='1.0:GUFDtACjFcc'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Bottle framework: handling form content'><vertical><video display_name='Lecture' youtube='1.0:sUUT-gIS5ik'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Bottle framework: using cookies'><vertical><video display_name='Lecture' youtube='1.0:Wk_1Lz_-gk4'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='The Pymongo driver'><vertical><video display_name='Lecture' youtube='1.0:u2kRRt861bU'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo driver, safe mode, exception processing'><vertical><video display_name='Lecture' youtube='1.0:GR6W-gHffXw'/></vertical></sequential><sequential graded='true' format='Homework' display_name='Homework 1.1'><vertical><video display_name='Lecture' youtube='1.0:r48N7GcDqVI'/></vertical><problem showanswer='due' attempts='3' url_name='Homework_1_1_problem' rerandomize='never' display_name='Quiz'>Install MongoDB on your computer and run it on the standard port.

<p>
Download the <a href="/static/handouts/hw1.tar">HW1 tarball (mac)</a> or <a href="/static/handouts/hw1.zip">zipfile (windows)</a>, expand it as follows:
</p>
Mac Users
<pre>
tar xvf hw1.tar
</pre>
Windows Users
<pre>
You probably don't have tar installed so right click on the hw1.zip file and choose "extract all"
</pre>
Use mongorestore to restore the dump into your running mongod. Do this by opening a terminal window (mac) or cmd window (windows) and navigating to the directory so that the dump directory is directly beneath you. Now type
<pre>
mongorestore dump
</pre>
Note you will need to have your path setup correctly to find mongorestore.
<p>
Now, using the Mongo shell, perform a findone on the collection called <em>hw1</em> in the database <em>m101</em>. That will return one document. Please provide the value corresponding to the "answer" key from the document returned.
</p><customresponse><textbox rows='4' cols='50' correct_answer="42"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''42'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 1.2'><problem showanswer='due' attempts='3' url_name='Homework_1_2_problem' rerandomize='never' display_name='Quiz'>Get Pymongo installed on your computer. To prove its installed, run the program:

<pre>
python hw1-2.py
</pre>

This program will print a numeric answer.  Please put just the number into the space below.  Note that you will need to get MongoDB installed and the homework dataset imported from the previous homework before attempting this problem.<customresponse><textbox rows='4' cols='50' correct_answer="1815"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''1815'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 1.3'><problem showanswer='due' attempts='3' url_name='Homework_1_3_problem' rerandomize='never' display_name='Quiz'>We are now going to test that you have bottle installed correctly and can run a bottle-based project. Run the hw1-3.py download as follows:
<pre>
python hw1-3.py
</pre>
It requires bottle to be installed correctly, your mongodb to be running, and that you have run mongorestore properly.  From a different terminal window type the following from the command line: curl http://localhost:8080/hw1/50
<p>
Type the answer into the box below
</p><customresponse><textbox rows='4' cols='50' correct_answer="53"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''53'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential></chapter><chapter start='2012-10-29T12:00' due='2012-11-08T04:00' display_name='Week2 - CRUD'><sequential graded='false' format='Quiz' display_name='Introduction to Week 2'><vertical><video display_name='Lecture' youtube='1.0:kB_9lXE-EbY'/></vertical><problem showanswer='attempted' url_name='Introduction_to_Week_2_problem' rerandomize='never' display_name='Quiz'>By the end of this week, you'll know which of the following?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>MongoDB's basic document creation, retrieval, modification, and removal operations<endouttext/></choice><choice correct='true'><startouttext/>Some features of the MongoDB shell, mongo<endouttext/></choice><choice correct='false'><startouttext/>How to measure performance of MongoDB operations<endouttext/></choice><choice correct='true'><startouttext/>How to manipulate MongoDB documents from Python<endouttext/></choice><choice correct='false'><startouttext/>How to analyze data in MongoDB collections<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:osal1NuP4UA'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Secrets of the Mongo Shell'><vertical><video display_name='Lecture' youtube='1.0:hJy10xgZXzc'/></vertical><problem showanswer='attempted' url_name='Secrets_of_the_Mongo_Shell_problem' rerandomize='never' display_name='Quiz'>What does the following fragment of JavaScript output?

<pre>
x = { "a" : 1 };
y = "a";
x[y]++;
print(x.a);
</pre>
<customresponse><textbox rows='4' cols='50' correct_answer="2"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''2'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem><vertical><video display_name='Answer' youtube='1.0:a6TFwpCoLoY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='BSON Introduced'><vertical><video display_name='Lecture' youtube='1.0:K3J6WvDW-Hc'/></vertical><problem showanswer='attempted' url_name='BSON_Introduced_problem' rerandomize='never' display_name='Quiz'>Which of the following are types available in BSON?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>Strings<endouttext/></choice><choice correct='true'><startouttext/>Floating-point numbers<endouttext/></choice><choice correct='false'><startouttext/>Complex numbers<endouttext/></choice><choice correct='true'><startouttext/>Arrays<endouttext/></choice><choice correct='true'><startouttext/>Objects<endouttext/></choice><choice correct='true'><startouttext/>Timestamps<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:4hsTQrMs-xY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Mongo shell, inserting docs'><vertical><video display_name='Lecture' youtube='1.0:RbRRvBLl7Qo'/></vertical><problem showanswer='attempted' url_name='Mongo_shell_inserting_docs_problem' rerandomize='never' display_name='Quiz'>Insert a document into the "fruit" collection with the attributes of "name" being "apple", "color" being "red", and "shape" being round. Assume that we have already issued the use command to get into the right database. Use the "insert" method.<customresponse><textbox rows='4' cols='50' correct_answer='db.fruit.insert({name:"apple", color:"red", shape:"round"})'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.fruit.insert({name:"apple", color:"red", shape:"round"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:4eqpL7ETQZQ'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Mongo shell, introdution to findOne'><vertical><video display_name='Lecture' youtube='1.0:w9V0fJsDwbQ'/></vertical><problem showanswer='attempted' url_name='Mongo_shell_introdution_to_findOne_problem' rerandomize='never' display_name='Quiz'>Use <em>findOne</em> on the collection <em>users</em> to find one document where the key <em>username</em> is "dwight", and retrieve only the key named <em>email</em>.<customresponse><textbox rows='4' cols='50' correct_answer='db.users.findOne ( { "username" : "dwight" } , { "_id" : false , "email" : true } );'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.findOne ( { "username" : "dwight" } , { "_id" : false , "email" : true } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:uN_wf5a3BE4'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Mongo shell, introduction to find'><vertical><video display_name='Lecture' youtube='1.0:8kKfFK6a0Ak'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Mongo shell, querying using field selection'><vertical><video display_name='Lecture' youtube='1.0:UIg86QjSoyY'/></vertical><problem showanswer='attempted' url_name='Mongo_shell_querying_using_field_selection_problem' rerandomize='never' display_name='Quiz'>Supposing a <em>scores</em> collection similar to the one presented, how would you find all documents with an essay score equal to 50 and only retrieve the <em>student</em> field?<customresponse><textbox rows='4' cols='50' correct_answer='db.scores.find({ type:"essay", score:50}, {student:true,_id:false});'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find({ type:"essay", score:50}, {student:true,_id:false});'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:ouHFZgtEAuU'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Querying using $gt and $lt'><vertical><video display_name='Lecture' youtube='1.0:FHLrz4VGzkg'/></vertical><problem showanswer='attempted' url_name='Querying_using_gt_and_lt_problem' rerandomize='never' display_name='Quiz'>Which of these finds documents with a score between 50 and 60, inclusive?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 , $lt : 60 } } );</text></choice><choice location='bottom' correct='true'><text>db.scores.find({ score : { $gte : 50 , $lte : 60 } } );</text></choice><choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 , $lte : 60 } } );</text></choice><choice location='bottom' correct='false'><text>db.scores.find({ score : { $gte : 50 , $lt : 60 } } );</text></choice><choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 } } );</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:tY7I1l8JdDI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Inequalities on strings'><vertical><video display_name='Lecture' youtube='1.0:imCCKOevU3c'/></vertical><problem showanswer='attempted' url_name='Inequalities_on_strings_problem' rerandomize='never' display_name='Quiz'>Which of the following will find all users with <em>name</em> between "F" and "Q"?<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>db.users.find( { name : { $gte : "F" ,  $lte : "Q" } } );<endouttext/></choice><choice correct='true'><startouttext/>db.users.find( { name : { $lte : "Q" , $gte : "F" } } );<endouttext/></choice><choice correct='false'><startouttext/>db.users.find( { name : { $gte : "f" ,  $lte : "Q" } } );<endouttext/></choice><choice correct='false'><startouttext/>db.users.find( { name :  { $lte : "Q" } });<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:ZRWT0lcHsoU'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using regexes, $exists, $type'><vertical><video display_name='Lecture' youtube='1.0:lI-jhqYf1JY'/></vertical><problem showanswer='attempted' url_name='Using_regexes_exists_type_problem' rerandomize='never' display_name='Quiz'>Write a query that retrieves documents from a <em>users</em> collection where the <em>name</em> has a "q" in it, and the document has an <em>email</em> field.<customresponse><textbox rows='4' cols='50' correct_answer='db.users.find({ name : { $regex : "q" }, email : { $exists: true } } );'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.find({ name : { $regex : "q" }, email : { $exists: true } } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:yMi7PwOoqXY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using $or'><vertical><video display_name='Lecture' youtube='1.0:BW5ElNCRZps'/></vertical><problem showanswer='attempted' url_name='Using_or_problem' rerandomize='never' display_name='Quiz'>How would you find all documents in the <em>scores</em> collection where the <em>score</em> is less than 50 or greater than 90?<customresponse><textbox rows='4' cols='50' correct_answer="db.scores.find( { $or : [ { score : { $lt : 50 } }, { score : { $gt : 90 } } ] } ) ;"/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find( { $or : [ { score : { $lt : 50 } }, { score : { $gt : 90 } } ] } ) ;'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:diimYkvr374'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using $and'><vertical><video display_name='Lecture' youtube='1.0:hYk7pjgjjzc'/></vertical><problem showanswer='attempted' url_name='Using_and_problem' rerandomize='never' display_name='Quiz'>What will the following query do?

<pre>db.scores.find( { score : { $gt : 50 }, score : { $lt : 60 } } );</pre><choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>Find all documents with score between 50 and 60<endouttext/></choice><choice correct='false'><startouttext/>Find all documents with score greater than 50<endouttext/></choice><choice correct='true'><startouttext/>Find all documents with score less than 60<endouttext/></choice><choice correct='false'><startouttext/>Explode like the Death Star<endouttext/></choice><choice correct='false'><startouttext/>None of the above<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:oIkSajy8NLw'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Querying inside arrays'><vertical><video display_name='Lecture' youtube='1.0:jvEqwW75Bus'/></vertical><problem showanswer='attempted' url_name='Querying_inside_arrays_problem' rerandomize='never' display_name='Quiz'>Which of the following documents would be returned by this query?

<pre>db.products.find( { tags : "shiny" } );</pre><choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='true'><startouttext/>{ _id : 42 , name : "Whizzy Wiz-o-matic", tags : [ "awesome", "shiny" , "green" ] }<endouttext/></choice><choice correct='false'><startouttext/>{ _id : 704 , name : "Fooey Foo-o-tron", tags : [ "blue", "mediocre" ] }<endouttext/></choice><choice correct='true'><startouttext/>{ _id : 1040 , name : "Snappy Snap-o-lux", tags : "shiny" }<endouttext/></choice><choice correct='false'><startouttext/>{ _id : 12345 , name : "Quuxinator", tags : [ ] }<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:gwECaa4N9Xc'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using $in and $all'><vertical><video display_name='Lecture' youtube='1.0:Lv-tYcQfuZg'/></vertical><problem showanswer='attempted' url_name='Using_in_and_all_problem' rerandomize='never' display_name='Quiz'>Which of the following documents matches this query?

<pre>db.users.find( { friends : { $all : [ "Joe" , "Bob" ] }, favorites : { $in : [ "running" , "pickles" ] } } )</pre><multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>{ name : "William" , friends : [ "Bob" , "Fred" ] , favorites : [ "hamburgers", "running" ] }</text></choice><choice location='bottom' correct='false'><text>{ name : "Stephen" , friends : [ "Joe" , "Pete" ] , favorites : [ "pickles", "swimming" ] }</text></choice><choice location='bottom' correct='true'><text>{ name : "Cliff" , friends : [ "Pete" , "Joe" , "Tom" , "Bob" ] , favorites : [ "pickles", "cycling" ] }</text></choice><choice location='bottom' correct='false'><text>{ name : "Harry" , friends : [ "Joe" , "Bob" ] , favorites : [ "hot dogs", "swimming" ] }</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:O8YQRq4vXig'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Queries with dot notation'><vertical><video display_name='Lecture' youtube='1.0:NrjFECIfwqk'/></vertical><problem showanswer='attempted' url_name='Queries_with_dot_notation_problem' rerandomize='never' display_name='Quiz'>Suppose a simple e-commerce product catalog called <em>catalog</em> with documents that look like this:

<pre>
{ product : "Super Duper-o-phonic", 
  price : 100000000000,
  reviews : [ { user : "fred", comment : "Great!" , rating : 5 },
              { user : "tom" , comment : "I agree with Fred, somewhat!" , rating : 4 } ],
  ... }
</pre>

Write a query that finds all products that cost more than 10,000 and that have a rating of 5 or better.<customresponse><textbox rows='4' cols='50' correct_answer='db.catalog.find( { price : { $gt : 10000 } , "reviews.rating" : { $gte : 5 } } ); '/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.catalog.find( { price : { $gt : 10000 } , "reviews.rating" : { $gte : 5 } } ); '''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:yiEjK_V008s'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Querying, cursors'><vertical><video display_name='Lecture' youtube='1.0:3jA6iFSEJOI'/></vertical><problem showanswer='attempted' url_name='Querying_cursors_problem' rerandomize='never' display_name='Quiz'>Recall the documents in the scores collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

Write a query that retrieves exam documents, sorted by score in descending order, skipping the first 50 and showing only the next 20.<customresponse><textbox rows='4' cols='50' correct_answer='db.scores.find( { type : "exam" } ).sort( { score : -1 } ).skip(50).limit(20)'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find( { type : "exam" } ).sort( { score : -1 } ).skip(50).limit(20)'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:djzpK7UIO94'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Counting results'><vertical><video display_name='Lecture' youtube='1.0:eKD5bVmNQMI'/></vertical><problem showanswer='attempted' url_name='Counting_results_problem' rerandomize='never' display_name='Quiz'>How would you count the documents in the <em>scores</em> collection where the type was "essay" and the score was greater than 90?<customresponse><textbox rows='4' cols='50' correct_answer='db.scores.count({ type:"essay", score:{$gt:90}});'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.count({ type:"essay", score:{$gt:90}});'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:Uozp0diXOc8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Wholesale Updating of a Document'><vertical><video display_name='Lecture' youtube='1.0:EBCk6W7x-OY'/></vertical><problem showanswer='attempted' url_name='Wholesale_Updating_of_a_Document_problem' rerandomize='never' display_name='Quiz'>Let's say you had a collection with the following document in it:
<pre>
{ "_id" : "Texas", "population" : 2500000, "land_locked" : 1 }
</pre>
and you issued the query:
<pre>
db.foo.update({_id:"Texas"},{population:30000000})
</pre>
What would be the state of the collection after the update?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>{ "_id" : "Texas", "population" : 2500000, "land_locked" : 1 }
</text></choice><choice location='bottom' correct='false'><text>{ "_id" : "Texas", "population" : 3000000, "land_locked" : 1 }
</text></choice><choice location='bottom' correct='true'><text>{ "_id" : "Texas", "population" : 30000000 }</text></choice><choice location='bottom' correct='false'><text>{ "_id" : ObjectId("507b7c601eb13126c9e3dcca"), "population" : 2500000 }</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:pwnRUdtI8lY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using the $set command'><vertical><video display_name='Lecture' youtube='1.0:9iMX2KxYAd8'/></vertical><problem showanswer='attempted' url_name='Using_the_set_command_problem' rerandomize='never' display_name='Quiz'>Given the document
<pre>
{'username':'splunker', 'country':'US', 'phone':'718-343-3433'}
</pre>
in the collection <em>users</em>, write the shell command for updating the country to 'RU' for only this user. <customresponse><textbox rows='4' cols='50' correct_answer="db.users.update({'username':'splunker'},{$set:{'country':'RU'}})"/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({'username':'splunker'},{$set:{'country':'RU'}})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:F6ZY_VVAXZ8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using the $unset command'><vertical><video display_name='Lecture' youtube='1.0:Kxd4MXBEx-I'/></vertical><problem showanswer='attempted' url_name='Using_the_unset_command_problem' rerandomize='never' display_name='Quiz'>Write an update query that will unset the <em>interests</em> key in the following document in the collection <em>users</em>.  The primary key is <em>username</em>.
<pre>
{'username':'jimmy', favorite_color:'blue', interests:['debating', 'politics']}
</pre><customresponse><textbox rows='4' cols='50' correct_answer="db.users.update({username:'jimmy'}, {$unset:{'interests':1}})"/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({username:'jimmy'}, {$unset:{'interests':1}})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:edqDAKMQTv4'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Using $push, $pop, $pull, $pushAll, $pullAll, $addToSet'><vertical><video display_name='Lecture' youtube='1.0:iHSwyr7bfQs'/></vertical><problem showanswer='attempted' url_name='Using_push_pop_pull_pushAll_pullAll_addToSet_problem' rerandomize='never' display_name='Quiz'>Suppose you have the following document in your <em>friends</em> collection:

<pre>
{ _id : "Mike", interests : [ "chess", "botany" ] }
</pre>

What will the result of the following updates be?

<pre>
db.friends.update( { _id : "Mike" }, { $push : { interests : "skydiving" } } );
db.friends.update( { _id : "Mike" }, { $pop : { interests : -1 } } );
db.friends.update( { _id : "Mike" }, { $addToSet : { interests : "skydiving" } } );
db.friends.update( { _id : "Mike" }, { $pushAll: { interests : [ "skydiving" , "skiing" ] } } );
</pre><customresponse><textbox rows='4' cols='50' correct_answer='{ _id : "Mike" , "interests" : [ "botany", "skydiving", "skydiving", "skiing" ] }'/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''{ _id : "Mike" , "interests" : [ "botany", "skydiving", "skydiving", "skiing" ] }'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:bGbiIGEM0FY'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Upserts'><vertical><video display_name='Lecture' youtube='1.0:dfvwrlVODGc'/></vertical><problem showanswer='attempted' url_name='Upserts_problem' rerandomize='never' display_name='Quiz'>After performing the following update on an empty collection
<pre>
db.foo.update({username:'bar'}, {'$set':{'interests':['cat', 'dog']}}, {upsert: true} );
</pre>
What could be the state of the collection.<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>{ "_id" : ObjectId("507b78232e8dfde94c149949"), "interests" : [ "cat", "dog" ]}<endouttext/></choice><choice correct='false'><startouttext/>{"interests" : [ "cat", "dog" ], "username" : "bar" }<endouttext/></choice><choice correct='false'><startouttext/>{}<endouttext/></choice><choice correct='true'><startouttext/>{ "_id" : ObjectId("507b78232e8dfde94c149949"), "interests" : [ "cat", "dog" ], "username" : "bar" }<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:Loo5XKQAryM'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Multi-update'><vertical><video display_name='Lecture' youtube='1.0:8uNNDduO09w'/></vertical><problem showanswer='attempted' url_name='Multi_update_problem' rerandomize='never' display_name='Quiz'>Recall the schema of the <em>scores</em> collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

How would you give every record whose score was less than 70 an extra 20 points?<customresponse><textbox rows='4' cols='50' correct_answer="db.scores.update( { score : { $lt: 70 } } , { $inc : { score : 20 } } , { multi : true } );"/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.update( { score : { $lt: 70 } } , { $inc : { score : 20 } } , { multi : true } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:B1DqIls06Tc'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Removing data'><vertical><video display_name='Lecture' youtube='1.0:PMhGgc3HCn4'/></vertical><problem showanswer='attempted' url_name='Removing_data_problem' rerandomize='never' display_name='Quiz'>Recall the schema of the <em>scores</em> collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

How would you delete every record whose score was less than 60?<customresponse><textbox rows='4' cols='50' correct_answer="db.scores.remove( { score : { $lt : 60 } } );"/>
<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.remove( { score : { $lt : 60 } } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:T3wcuZHm6Ac'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='getLastError'><vertical><video display_name='Lecture' youtube='1.0:kUulkJQvH_A'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, find, find_one and cursors'><vertical><video display_name='Lecture' youtube='1.0:kXu5V3MlFI0'/></vertical><problem showanswer='attempted' url_name='Pymongo_find_find_one_and_cursors_problem' rerandomize='never' display_name='Quiz'>In the following code snippet:
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the school database
db=connection.school
scores = db.scores
     
try:
        xxxx
        
except:
        print "Unexpected error:", sys.exc_info()[0]


print doc
</pre>
please enter the one line of python code that would be needed in in place of xxxx to find one document in the collection.<customresponse><textbox rows='4' cols='50' correct_answer="doc = scores.find_one()"/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''doc = scores.find_one()'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:d-EOPb3_YVI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, using field selection'><vertical><video display_name='Lecture' youtube='1.0:pCRMWfF_SC8'/></vertical><problem showanswer='attempted' url_name='Pymongo_using_field_selection_problem' rerandomize='never' display_name='Quiz'>Which of the following could work using pymongo, depending on variable names, to select out just the student_id from the scores collection using a find command.<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>cursor = students.find({'student_id':1, '_id':0})</text></choice><choice location='bottom' correct='false'><text>cursor = students.find({'student_id':1})</text></choice><choice location='bottom' correct='true'><text>cursor = students.find({}, {'student_id':1, '_id':0})</text></choice><choice location='bottom' correct='false'><text>cursor = students.find({}, {student_id:1, _id:0})</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:vMNLxyQ47BM'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, using $gt and $lt'><vertical><video display_name='Lecture' youtube='1.0:p5ltB0g3lUo'/></vertical><problem showanswer='attempted' url_name='Pymongo_using_gt_and_lt_problem' rerandomize='never' display_name='Quiz'>In the following code, what is the correct line of code, marked by xxxx,  to search for all quiz scores that are greater than 20 and less than 90.
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the school database
db=connection.school
scores = db.scores


def find():

    print "find, reporting for duty"

    xxxx

    try:
        iter = scores.find(query)

    except:
        print "Unexpected error:", sys.exc_info()[0]
        
    return iter

find()
</pre>

<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text> query = {'score':{'$gt':20, '$lt':90}}</text></choice><choice location='bottom' correct='true'><text> query = {'type':'quiz', 'score':{'$gt':20, '$lt':90}}</text></choice><choice location='bottom' correct='false'><text> query = {'type':'quiz', '$gt':{'score':20}, '$lt':{'score':90}}</text></choice><choice location='bottom' correct='false'><text> query = {'type':'quiz', 'score':{$gt:20, $lt:90}}</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:2kzdSZmJ8jM'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Importing from Reddit'><vertical><video display_name='Lecture' youtube='1.0:dd49ULz7y6Q'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, using a regex'><vertical><video display_name='Lecture' youtube='1.0:UIes2_2rBWE'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, using dot notation'><vertical><video display_name='Lecture' youtube='1.0:kiJRqBbCSGk'/></vertical><problem showanswer='attempted' url_name='Pymongo_using_dot_notation_problem' rerandomize='never' display_name='Quiz'>In the following code, what do you think will happen if a document that matches the query doesn't have a key called <i>media.oembed.url</i>?
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the reddit database
db=connection.reddit
scores = db.stories


def find():

    print "find, reporting for duty"

    query = {'media.oembed.type':'video'}
    projection = {'media.oembed.url':1, '_id':0}

    try:
        iter = scores.find(query, projection)

    except:
        print "Unexpected error:", sys.exc_info()[0]

    sanity = 0
    for doc in iter:
        print doc
        sanity += 1
        if (sanity > 10):
            break
        

find()

</pre>
<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>Pymongo will throw an exception.</text></choice><choice location='bottom' correct='true'><text>Pymongo will return an empty document</text></choice><choice location='bottom' correct='false'><text>Pymongo will return a document with the following structure {media:{oembed:{url:{}}}}</text></choice><choice location='bottom' correct='false'><text>There is not enough information to know</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:5mpm64vncL0'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, sort, skip and limit'><vertical><video display_name='Lecture' youtube='1.0:F1bSsbt5Qfk'/></vertical><problem showanswer='attempted' url_name='Pymongo_sort_skip_and_limit_problem' rerandomize='never' display_name='Quiz'>Supposed you had the following documents in a collection named things.
<pre>
{ "_id" : 0, "value" : 10 }
{ "_id" : 2, "value" : 5 }
{ "_id" : 3, "value" : 7 }
{ "_id" : 4, "value" : 20 }
</pre>
If you performed the following query in pymongo:
<pre>
cursor = things.find().skip(3).limit(1).sort('value",pymongo.DESCENDING)
</pre>
which document would be returned?<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>The document with _id=0</text></choice><choice location='bottom' correct='true'><text>The document with _id=2</text></choice><choice location='bottom' correct='false'><text>The document with _id=3</text></choice><choice location='bottom' correct='false'><text>The doucment with _id=4</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:cUNoJN6Ii-I'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, Sort, final thoughts'><vertical><video display_name='Lecture' youtube='1.0:hwUg8r7a-d8'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, Inserting'><vertical><video display_name='Lecture' youtube='1.0:1buD4Ern9rA'/></vertical><problem showanswer='attempted' url_name='Pymongo_Inserting_problem' rerandomize='never' display_name='Quiz'>Do you expect the second insert below to succeed?
<pre>

# get a handle to the school database
db=connection.school
people = db.people

doc = {"name":"Andrew Erlichson", "company":"10gen",
              "interests":['running', 'cycling', 'photography']}

try:
        people.insert(doc)   # first insert
        del(doc['_id'])
        people.insert(doc)   # second insert

except:
        print "Unexpected error:", sys.exc_info()[0]

</pre><multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>No, because the _id will be a duplicate in the collection</text></choice><choice location='bottom' correct='false'><text>No, because the del call will delete the entire record in python</text></choice><choice location='bottom' correct='true'><text>Yes, because the del call will remove the _id key added by the pymongo driver in the first insert</text></choice><choice location='bottom' correct='false'><text>Yes, because the pymongo driver always adds a unique _id field on insert.</text></choice></choicegroup></multiplechoiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:pEMyrKDzgFg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, Updating'><vertical><video display_name='Lecture' youtube='1.0:u6iRURy8rY0'/></vertical><problem showanswer='attempted' url_name='Pymongo_Updating_problem' rerandomize='never' display_name='Quiz'>In the following code fragment, what is the python expression in place of xxxx to set a new key "examiner" to be "Jones"

Please use the $set operator

<pre>

def using_set():

    print "updating record using set"
    # get a handle to the school database
    db=connection.school
    scores = db.scores


    try:
        # get the doc
        score = scores.find_one({'student_id':1, 'type':'homework'})
        print "before: ", score

        # update using set
        scores.update({'student_id':1, 'type':'homework'},
                      xxxx)

        score = scores.find_one({'student_id':1, 'type':'homework'})
        print "after: ", score

    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise

</pre>
<customresponse><textbox rows='4' cols='50' correct_answer="{'$set':{'examiner':'Jones'}}"/>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''{'$set':{'examiner':'Jones'}}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse></problem><vertical><video display_name='Answer' youtube='1.0:Cyk5uzO-65w'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, upserts'><vertical><video display_name='Lecture' youtube='1.0:hcGo9lV9HwI'/></vertical><problem showanswer='attempted' url_name='Pymongo_upserts_problem' rerandomize='never' display_name='Quiz'>Suppose we would like to upsert the following document into the collection <i>stuff</i>:
<pre>
{_id:"bat", friend:'ball', cousin:'glove'}
</pre>
Which of the following python statements work. Check all that apply.<choiceresponse direction='vertical'><checkboxgroup type='MultipleChoice'><choice correct='false'><startouttext/>stuff.update({'_id':'bat'},  {'friend':'ball', 'cousin':'glove'}, upsert=True)<endouttext/></choice><choice correct='false'><startouttext/>stuff.update({'_id':'bat'},  {'friend':'ball', 'cousin':'glove'}, upsert=False)<endouttext/></choice><choice correct='true'><startouttext/>stuff.update({'_id':'bat'},  {'_id':'bat', 'friend':'ball', 'cousin':'glove'}, upsert=True)<endouttext/></choice><choice correct='true'><startouttext/>stuff.update({'_id':'bat'},  {'$set': {'friend':'ball', 'cousin':'glove'}}, upsert=True)<endouttext/></choice></checkboxgroup></choiceresponse></problem><vertical><video display_name='Answer' youtube='1.0:tMEohyZX0cI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Pymongo, find_and_modify'><vertical><video display_name='Lecture' youtube='1.0:rQ8Oml5e6PI'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Blog, User Interface'><vertical><video display_name='Lecture' youtube='1.0:QA80WBg0hLg'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Blog, Session Management'><vertical><video display_name='Lecture' youtube='1.0:sNigml3JoY0'/></vertical></sequential><sequential graded='false' format='Quiz' display_name='Blog, Internals'><vertical><video display_name='Lecture' youtube='1.0:tTqQZvBGhyU'/></vertical></sequential><sequential graded='true' format='Homework' display_name='Homework 2.1'><problem showanswer='due' attempts='3' url_name='Homework_2_1_problem' rerandomize='never' display_name='Quiz'>In this problem, you will be using a collection of student scores that is similar to what we used in the lessons. Please download the <a href="/static/handouts/grades.js">grades.js</a> file and import it into your local mongo database as follows:
<pre>
mongoimport -d students -c grades &lt; grades.js
</pre>
The dataset contains 4 scores for 200 students.
<p>
First, letâ€™s confirm your data is intact; the number of documents should be 800.
</p>
<pre>
> use students
> db.grades.count()
800
</pre>
<p>
This next query, which uses the aggregation framework that we have not taught yet, will tell you the <em>student_id</em> with the highest average score:
</p>

<pre>
> db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>
<b><i>Note:  Aggregation requires <a href="http://www.mongodb.org/downloads">mongodb 2.2</a> or above.</i></b>

<p>
The answer, deep in the resulting document, should be <em>student_id</em> 164 with an average of approximately 89.3.
</p>

Now itâ€™s your turn to analyze the data set. Find all exam scores greater than or equal to 65. and sort those scores from lowest to highest.
<p>What is the <em>student_id</em> of the lowest exam score above 65?</p>
<multiplechoiceresponse direction='vertical'><choicegroup type='MultipleChoice'><choice location='bottom' correct='false'><text>115</text></choice><choice location='bottom' correct='true'><text>22</text></choice><choice location='bottom' correct='false'><text>48</text></choice><choice location='bottom' correct='false'><text>57</text></choice><choice location='bottom' correct='false'><text>87</text></choice></choicegroup></multiplechoiceresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 2.2'><problem showanswer='due' attempts='3' url_name='Homework_2_2_problem' rerandomize='never' display_name='Quiz'><p>
Write a program in the language of your choice that will remove the grade of type "homework" with the lowest score for each student from the <a href="/static/handouts/grades.js">dataset</a> that you imported in HW 2.1.  Since each document is one grade, it should remove one document per student.
</p>
<p>
<i>Hint/spoiler</i>: If you select homework grade-documents, sort  by student and then by score, you can iterate through and find the lowest score for each student by noticing a change in student id. As you notice that change of student_id, remove the document.
</p>

<p>
To confirm you are on the right track, here are some queries to run after you process the data with the correct answer shown:
</p>

Let us count the number of grades we have:
<pre>
> db.grades.count() 
600
</pre>

Now let us find the student who holds the 101st best grade across all grades:
<pre>
> db.grades.find().sort({'score':-1}).skip(100).limit(1)
{ "_id" : ObjectId("50906d7fa3c412bb040eb709"), "student_id" : 100, "type" : "homework", "score" : 88.50425479139126 }
</pre>

Now let us sort the students by student_id, score and see what the top five docs are:
<pre>
> db.grades.find({},{'student_id':1, 'type':1, 'score':1, '_id':0}).sort({'student_id':1, 'score':1, }).limit(5)
{ "student_id" : 0, "type" : "quiz", "score" : 31.95004496742112 }
{ "student_id" : 0, "type" : "exam", "score" : 54.6535436362647 }
{ "student_id" : 0, "type" : "homework", "score" : 63.98402553675503 }
{ "student_id" : 1, "type" : "homework", "score" : 44.31667452616328 }
{ "student_id" : 1, "type" : "exam", "score" : 74.20010837299897 }
</pre>

<p>
To verify that you have completed this task correctly, provide the identify of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document. 
</p>
<pre>
> db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>

Enter the student ID below. Please enter just the number, with no spaces, commas or other characters.<customresponse><textbox rows='4' cols='50' correct_answer="54"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''54'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential><sequential graded='true' format='Homework' display_name='Homework 2.3'><problem showanswer='due' attempts='3' url_name='Homework_2_3_problem' rerandomize='never' display_name='Quiz'><em>Blog User Sign-up and Login</em>
<p>
Download <a href="/static/handouts/hw2.3.zip">hw2.3.zip</a> or <a href="/static/handouts/hw2.3.tar">hw2.3.tar</a> and unpack.
</p>
<p>
You should see two files at the highest level: <i>blog.py</i> and <i>user.py</i>. There is also a views directory which contains the templates for the project. 
</p>
<p>
The project roughly follows the model/view/controller paradigm. <i>user.py</i> is the model. <i>blog.py</i> is the controller.  The templates comprise the view.
</p>

<p>
If everything is working properly, you should be able to start the blog by typing:
</p>
<pre>
python blog.py
</pre>

<p>
Note that this project requires the following python modules be installed on your computer: cgi, hmac, re, datetime, random, json, sys, string, hashlib, bson, urllib, urllib2, random, re, pymongo, and bottle. A typical Python installation will already have most of these installed except <i>pymongo</i> and <i>bottle</i>.
</p>
<p>
If you have python-setuptools installed, the command "easy_install" makes this simple.  Any other missing packages will show up when <i>validate.py</i> is run, and can be installed in a similar fashion.
</p>
<pre>
$ easy_install pymongo bottle
</pre>
<p>
If you goto <a href="http://localhost:8082/">http://localhost:8082</a> you should see a message â€œthis is a placeholder for the blogâ€
</p>

<p>
Here are some URLs that must work when you are done.
</p>
<pre>
http://localhost:8082/signup
http://localhost:8082/login
http://localhost:8082/logout
</pre>

<p>
When you login or sign-up, the blog will redirect to 
http://localhost:8082/welcome
and that must work properly, welcoming the user by username
</p>
<p>
We have removed two pymongo statements from user.py and marked the area where you need to work with XXX. You should not need to touch any other code.  The pymongo statements that you are going to add will add a new user upon sign-up and validate a login by retrieving the right user document. 
</p>
<p>
The blog stores its data in the blog database in two collections, <i>users</i> and <i>sessions</i>.  Here are two example docs for a username â€˜erlichsonâ€™ with password â€˜fubarâ€™. You can insert these if you like, but you donâ€™t need to.
</p>
<pre>
> db.users.find()
{ "_id" : "erlichson", "password" : "d3caddd3699ef6f990d4d53337ed645a3804fac56207d1b0fa44544db1d6c5de,YCRvW" }
> 
> db.sessions.find()
{ "_id" : ObjectId("50907cda49037223b802117d"), "username" : "erlichson" }
> 
</pre>

<p>
Once you have the the project working, the following steps should work:
</p>
<ul>
<li>go to http://localhost:8082/signup</li>
<li>create a user</li>
</ul>
It should redirect you to the welcome page and say: welcome username, where username is the user you signed up with.  Now
<ul>
<li>Goto http://localhost:8082/logout</li>
<li>Now login http://localhost:8082/login.</li>
</ul>
<br/>
<p>
Ok, now itâ€™s time to validate you got it all working.
</p>
<p>
There was one additional program that should have been downloaded in the project called <i>validate.py</i>.
</p>
<pre>
python validate.py
</pre>
If you got it right, it will provide a validation code for you to enter into the box below. Enter just the code, no spaces.
<customresponse><textbox rows='4' cols='50' correct_answer="h726dgdf63289wjaklf9467ghdsjkf"/><answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''h726dgdf63289wjaklf9467ghdsjkf'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]></answer></customresponse></problem></sequential></chapter></course>