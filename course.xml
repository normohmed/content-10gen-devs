<course url_name='2012_Fall' org='10gen' course='M101' start='2012-10-22T00:00' display_name='MongoDB for Developers'>
<chapter start='2012-10-22T00:00' display_name='Week 1 - Introduction'>
<sequential graded='false' display_name='Welcome to M101' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:179MiZSibco'/>
<html>
<h2>Lecture Notes</h2>
<h4>Sample Lecture Notes</h4>
<ul>
<li>Note 1</li>
<li>Note 2</li>
</ul></html>
</vertical>
<problem showanswer='attempted' url_name='Welcome_to_M101_problem' rerandomize='never' display_name='Quiz: Welcome to M101'>
What counts toward your final grade in the class?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Quizzes<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Homeworks<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Final Exam<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Class Participation<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:xVfrAfEyfb0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='What is MongoDB?' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Lfl8hdQOi6Y'/>
</vertical>
<problem showanswer='attempted' url_name='What_is_MongoDB__problem' rerandomize='never' display_name='Quiz: What is MongoDB?'>
Which of the following statements are true about MongoDB?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>MongoDB is document oriented.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>MongoDB supports Joins.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>MongoDB is schemaless<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>MongoDB supports SQL.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:h80NwJJZM-g'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo Relative to Relational' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:-KIC1LXxcGM'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_Relative_to_Relational_problem' rerandomize='never' display_name='Quiz: Mongo Relative to Relational'>
Which features did MongoDB omit in order to retain scalability?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Joins<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Indexes<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Secondary Indexes<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Transactions across multiple collections<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:IAvnMgvHuLw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Overview of Building an app with Mongo'>
<vertical>
<video display_name='Lecture' youtube='1.0:_e0J06elxb8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Quick Introduction to the Mongo Shell' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:f-lyGAMnNY4'/>
</vertical>
<problem showanswer='attempted' url_name='Quick_Introduction_to_the_Mongo_Shell_problem' rerandomize='never' display_name='Quiz: Quick Introduction to the Mongo Shell'>
Which of the following expressions are valid JSON documents?
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>{a:1, b:2, c:3}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{a,1; b,4, c,6}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{a:1; b:1; c:4}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>(A,1; b:2; c,4}<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:YQTqdLe3W4M'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON introduced' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:2jsJeH8q6YM'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_introduced_problem' rerandomize='never' display_name='Quiz: JSON introduced'>
Which of the following are valid JSON documents?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>{a:1, b:2, c: 3}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{a:1, b:2, c:[1,2,3,4,5]}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{a:1, b:{}, c: [ { a:1, b:2}, 5, 6]}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{  }<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:uWcOsdV4Iz4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing MongoDB (mac)'>
<vertical>
<video display_name='Lecture' youtube='1.0:6VFukRETCTg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing MongoDB (windows)'>
<vertical>
<video display_name='Lecture' youtube='1.0:hX5louVryOQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing Bottle and Python (mac)'>
<vertical>
<video display_name='Lecture' youtube='1.0:vxTN6KFegLg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing Python (windows)'>
<vertical>
<video display_name='Lecture' youtube='1.0:njfPdZTmTrI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing Bottle.py (windows)'>
<vertical>
<video display_name='Lecture' youtube='1.0:OhEpXjL0vt8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing PyMongo (mac)'>
<vertical>
<video display_name='Lecture' youtube='1.0:XRJawbpWxtg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing PyMongo (windows)'>
<vertical>
<video display_name='Lecture' youtube='1.0:YwWc6HZ0LWo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hello World, Mongo Style'>
<vertical>
<video display_name='Lecture' youtube='1.0:IG7PntLyv2E'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hello World on a Web Server'>
<vertical>
<video display_name='Lecture' youtube='1.0:8_o6nyenZbk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo is Schemaless'>
<vertical>
<video display_name='Lecture' youtube='1.0:K6dlBbH_XHI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Revisited'>
<vertical>
<video display_name='Lecture' youtube='1.0:zbYCcMWJGNY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Arrays' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:JkK9n6_ahVk'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Arrays_problem' rerandomize='never' display_name='Quiz: JSON Arrays'>
Write the JSON for a simple document containing a single key "fruit" that has as its value an array containing three strings: "apple", "pear", and "peach"<customresponse>
<textbox rows='4' cols='50' correct_answer="{'fruit': ['apple', 'pear', 'peach']}"> </textbox>
<answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{'fruit': ['apple', 'pear', 'peach']}'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ciuq7XPqHKI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Subdocuments' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:vrYAEH3g13M'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Subdocuments_problem' rerandomize='never' display_name='Quiz: JSON Subdocuments'>
Write a JSON document with a single key, "address" that has as it value another document with the keys 
'street_address', 'city', 'state', 'zipcode', with the following values: 'street_address' is "23 Elm Drive", 'city' is "Palo Alto", 'state' is "California", 'zipcode' is "94305"<customresponse>
<textbox rows='4' cols='50' correct_answer="{'address': {'street_address': &quot;23 Elm Drive&quot;, 'city' : &quot;Palo Alto&quot;, 'state': &quot;California&quot;, 'zipcode': &quot;94305&quot;} }"> </textbox>
<answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{'address': {'street_address': "23 Elm Drive", 'city' : "Palo Alto", 'state': "California", 'zipcode': "94305"} }'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:NGp_y6BaEMw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Spec'>
<vertical>
<video display_name='Lecture' youtube='1.0:kOrsT94-A28'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Introduction to our class project, the blog'>
<vertical>
<video display_name='Lecture' youtube='1.0:ePi3kDoexoM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog in Relational Tables' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:boR2y9MHCa0'/>
</vertical>
<problem showanswer='attempted' url_name='Blog_in_Relational_Tables_problem' rerandomize='never' display_name='Quiz: Blog in Relational Tables'>
letâ€™s assume that our blog can be modeled with the following relational tables:

<pre>
authors:
	author_id,
	name,
	email,
	password

posts:
	post_id,
	author_id
	title,
	body,	
	publication_date

comments:
	comment_id,
	name, 
	email,
	comment_text

post_comments:
	post_id,
	comment_id


tags
	tag_id
	name

post_tags
	post_id
	tag_id
</pre>

In order to display a blog post with its comments and tags, how many tables will need to be accessed?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>3</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
<choice location='bottom' correct='true'><text>6</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vB-4AbbLKeg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog in Documents' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ZjwCzyqKVdY'/>
</vertical>
<problem showanswer='attempted' url_name='Blog_in_Documents_problem' rerandomize='never' display_name='Quiz: Blog in Documents'>
Given the document schema that we proposed for the blog, how many collections would we need to access to display the blog home page?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>0</text></choice>
<choice location='bottom' correct='true'><text>1</text></choice>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>4</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:WJblHPsp1p4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Intro to Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:6XE3wZCPiZ8'/>
</vertical>
<problem showanswer='attempted' url_name='Intro_to_Schema_Design_problem' rerandomize='never' display_name='Quiz: Intro to Schema Design'>
In which scenario is it impossible to embed data within a document (you must put the data in it a separate collection). Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>The data would be duplicated across multiple objects within a collection.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>You need an index on the data element.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The embedded data could exceed the 16MB document limit within MongoDB<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The data is not isomorphic.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:wiwOEG_6ojs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Intro to Python' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:-cAtffa59FM'/>
</vertical>
<problem showanswer='attempted' url_name='Intro_to_Python_problem' rerandomize='never' display_name='Quiz: Intro to Python'>
Write an expression to concatenate two strings "hat" and "pin" in python to the string "hatpin"<customresponse>
<textbox rows='4' cols='50' correct_answer='"hat" + "pin"'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''"hat" + "pin"'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:PuyAdxxzSk0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:H1BOYfbnPq8'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_problem' rerandomize='never' display_name='Quiz: Python Lists'>
Write the to code to initialize a list with the items "hammer", "nail" and "wall" and assign the list to the variable named "things".<customresponse>
<textbox rows='4' cols='50' correct_answer='things = ["hammer", "nail", "wall"]'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things = ["hammer", "nail", "wall"]'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:8WdnrhlfSLE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists, Manipulating' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:PHii2QYNyB8'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_Manipulating_problem' rerandomize='never' display_name='Quiz: Python Lists, Manipulating'>
Write the code to append the item "hammer" onto a list named things.

<p>Please use double quotes at this time.</p><customresponse>
<textbox rows='4' cols='50' correct_answer='things.append("hammer")'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things.append("hammer")'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ZSraFzkEDzs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists, Slice Operator' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:vNyIZNWK0rw'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_Slice_Operator_problem' rerandomize='never' display_name='Quiz: Python Lists, Slice Operator'>
things = ['apples', 'orange', 'pear', 'grape', 'kiwi']. What is the slice notation that will return the sublist ['orange', 'pear']?
<customresponse>
<textbox rows='4' cols='50' correct_answer="things[1:3]"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things[1:3]'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vE498xAFoGc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists, Inclusion' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:QXUMUvHB2Ws'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_Inclusion_problem' rerandomize='never' display_name='Quiz: Python Lists, Inclusion'>
given a python list called "fruit", write an if statement to check whether "apple" is in the list.

<p>Please use double quotes at this time.</p><customresponse>
<textbox rows='4' cols='50' correct_answer='if "apple" in fruit:&#10;'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''if "apple" in fruit:
'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:LdA0__D4zLI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python, Working with Dicts' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:_AbCyE0uKmE'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Working_with_Dicts_problem' rerandomize='never' display_name='Quiz: Python, Working with Dicts'>
Initialize a new dict named "colors" with the following key values pairs: sky is blue, sea is blue. earth is brown.

<i>Note:  Please preserve the order of these keys when you enter your answer.</i><customresponse>
<textbox rows='4' cols='50' correct_answer="colors = {'sky': 'blue', 'sea' : 'blue', 'earth': 'brown'}"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''colors = {'sky': 'blue', 'sea' : 'blue', 'earth': 'brown'}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:edEYrBoa7Ao'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: Dicts and Lists together' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:9k1XvuoGdrk'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Dicts_and_Lists_together_problem' rerandomize='never' display_name='Quiz: Python: Dicts and Lists together'>
Initialize a new dict with a single key, "animals" whose value is the list "dog", "cat", "zebra" and assign the entire expression to variable named "things"<customresponse>
<textbox rows='4' cols='50' correct_answer="things = {'animals' : ['dog', 'cat', 'zebra']}"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things = {'animals' : ['dog', 'cat', 'zebra']}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Gqb-OUFcQas'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: for loops, with Lists' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:zMqLCtf3ML4'/>
</vertical>
<problem showanswer='attempted' url_name='Python_for_loops_with_Lists_problem' rerandomize='never' display_name='Quiz: Python: for loops, with Lists'>
What does the following code print?

<pre>
sum = 0
numbers = [1,2,3,5,8]
for i in numbers:
  sum = sum + i
print i
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer="8"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''8'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ohA78_D5Rn8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: for loops with dicts' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:HHTICY6rUGI'/>
</vertical>
<problem showanswer='attempted' url_name='Python_for_loops_with_dicts_problem' rerandomize='never' display_name='Quiz: Python: for loops with dicts'>
<pre>
people = {'name':'Bob', 'hometown': "Palo Alto", 'favorite_color': 'red'}
for item in people:
  if (item == 'favorite_color'):
     print  people[item]
</pre>

What does this program print?<customresponse>
<textbox rows='4' cols='50' correct_answer="red"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''red'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:OnkPdMP1fVc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: Combining Dicts and Lists' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ome7jDN_lH0'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Combining_Dicts_and_Lists_problem' rerandomize='never' display_name='Quiz: Python: Combining Dicts and Lists'>

<pre>
obj = {'a':1,'b': 2, 'c': [1, 3, 5]}

sum = 0
if 'c' in obj:
   for n in obj['c']:
     sum = sum + n

print sum
</pre>
     <customresponse>
<textbox rows='4' cols='50' correct_answer="9"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''9'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Y6NKd6xUC6M'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: while loops'>
<vertical>
<video display_name='Lecture' youtube='1.0:TEdFAheS5UE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: function calls'>
<vertical>
<video display_name='Lecture' youtube='1.0:PizwcirYuGY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: exception handling'>
<vertical>
<video display_name='Lecture' youtube='1.0:nrZYqF9KwaU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: Url Handlers'>
<vertical>
<video display_name='Lecture' youtube='1.0:x5TlvbWxjL0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: using views'>
<vertical>
<video display_name='Lecture' youtube='1.0:GUFDtACjFcc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: handling form content'>
<vertical>
<video display_name='Lecture' youtube='1.0:sUUT-gIS5ik'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: using cookies'>
<vertical>
<video display_name='Lecture' youtube='1.0:Wk_1Lz_-gk4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Pymongo driver'>
<vertical>
<video display_name='Lecture' youtube='1.0:u2kRRt861bU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo driver, safe mode, exception processing'>
<vertical>
<video display_name='Lecture' youtube='1.0:GR6W-gHffXw'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.1' format='Homework' due='Oct 30 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:r48N7GcDqVI'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='Homework_1_1_problem' rerandomize='never' display_name='Quiz: Homework 1.1'>
Install MongoDB on your computer and run it on the standard port.

<p>
Download the <a href="/static/handouts/hw1.tar">HW1 tarball (mac)</a> or <a href="/static/handouts/hw1.zip">zipfile (windows)</a>, expand it as follows:
</p>
Mac Users
<pre>
tar xvf hw1.tar
</pre>
Windows Users
<pre>
You probably don't have tar installed so right click on the hw1.zip file and choose "extract all"
</pre>
Use mongorestore to restore the dump into your running mongod. Do this by opening a terminal window (mac) or cmd window (windows) and navigating to the directory so that the dump directory is directly beneath you. Now type
<pre>
mongorestore dump
</pre>
Note you will need to have your path setup correctly to find mongorestore.
<p>
Now, using the Mongo shell, perform a findone on the collection called <em>hw1</em> in the database <em>m101</em>. That will return one document. Please provide the value corresponding to the "answer" key from the document returned.
</p><customresponse>
<textbox rows='4' cols='50' correct_answer="42"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''42'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:memPfvehjGo'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.2' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_2_problem' rerandomize='never' display_name='Quiz: Homework 1.2'>
Get Pymongo installed on your computer. To prove its installed, run the program:

<pre>
python hw1-2.py
</pre>

This program will print a numeric answer.  Please put just the number into the space below.  Note that you will need to get MongoDB installed and the homework dataset imported from the previous homework before attempting this problem.<customresponse>
<textbox rows='4' cols='50' correct_answer="1815"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''1815'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ZeF4fdLDoMY'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.3' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_3_problem' rerandomize='never' display_name='Quiz: Homework 1.3'>
We are now going to test that you have bottle installed correctly and can run a bottle-based project. Run the hw1-3.py download as follows:
<pre>
python hw1-3.py
</pre>
It requires bottle to be installed correctly, your mongodb to be running, and that you have run mongorestore properly.  From a different terminal window type the following from the command line: curl http://localhost:8080/hw1/50
<p>
Type the answer into the box below
</p><customresponse>
<textbox rows='4' cols='50' correct_answer="53"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''53'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cmSs92zp4aA'/>
</vertical>
</sequential>
</chapter>
<chapter start='Oct 29 2012' display_name='Week 2 - CRUD'>
<sequential graded='false' display_name='Introduction to Week 2' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:kB_9lXE-EbY'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_Week_2_problem' rerandomize='never' display_name='Quiz: Introduction to Week 2'>
By the end of this week, you'll know which of the following?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>MongoDB's basic document creation, retrieval, modification, and removal operations<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Some features of the MongoDB shell, mongo<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>How to measure performance of MongoDB operations<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>How to manipulate MongoDB documents from Python<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>How to analyze data in MongoDB collections<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:osal1NuP4UA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Secrets of the Mongo Shell' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:hJy10xgZXzc'/>
</vertical>
<problem showanswer='attempted' url_name='Secrets_of_the_Mongo_Shell_problem' rerandomize='never' display_name='Quiz: Secrets of the Mongo Shell'>
What does the following fragment of JavaScript output?

<pre>
x = { "a" : 1 };
y = "a";
x[y]++;
print(x.a);
</pre>
<customresponse>
<textbox rows='4' cols='50' correct_answer="2"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''2'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:a6TFwpCoLoY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='BSON Introduced' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:K3J6WvDW-Hc'/>
</vertical>
<problem showanswer='attempted' url_name='BSON_Introduced_problem' rerandomize='never' display_name='Quiz: BSON Introduced'>
Which of the following are types available in BSON?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Strings<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Floating-point numbers<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Complex numbers<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Arrays<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Objects<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Timestamps<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4hsTQrMs-xY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, inserting docs' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:RbRRvBLl7Qo'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_shell_inserting_docs_problem' rerandomize='never' display_name='Quiz: Mongo shell, inserting docs'>
Insert a document into the "fruit" collection with the attributes of "name" being "apple", "color" being "red", and "shape" being round. Assume that we have already issued the use command to get into the right database. Use the "insert" method.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.fruit.insert({name:"apple", color:"red", shape:"round"})'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.fruit.insert({name:"apple", color:"red", shape:"round"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4eqpL7ETQZQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, introdution to findOne' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:w9V0fJsDwbQ'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_shell_introdution_to_findOne_problem' rerandomize='never' display_name='Quiz: Mongo shell, introdution to findOne'>
Use <em>findOne</em> on the collection <em>users</em> to find one document where the key <em>username</em> is "dwight", and retrieve only the key named <em>email</em>.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.users.findOne ( { "username" : "dwight" } , { "_id" : false , "email" : true } );'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.findOne ( { "username" : "dwight" } , { "_id" : false , "email" : true } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:uN_wf5a3BE4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, introduction to find'>
<vertical>
<video display_name='Lecture' youtube='1.0:8kKfFK6a0Ak'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, querying using field selection' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:UIg86QjSoyY'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_shell_querying_using_field_selection_problem' rerandomize='never' display_name='Quiz: Mongo shell, querying using field selection'>
Supposing a <em>scores</em> collection similar to the one presented, how would you find all documents with an essay score equal to 50 and only retrieve the <em>student</em> field?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.scores.find({ type:"essay", score:50}, {student:true,_id:false});'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find({ type:"essay", score:50}, {student:true,_id:false});'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ouHFZgtEAuU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Querying using $gt and $lt' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:FHLrz4VGzkg'/>
</vertical>
<problem showanswer='attempted' url_name='Querying_using_gt_and_lt_problem' rerandomize='never' display_name='Quiz: Querying using $gt and $lt'>
Which of these finds documents with a score between 50 and 60, inclusive?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 , $lt : 60 } } );</text></choice>
<choice location='bottom' correct='true'><text>db.scores.find({ score : { $gte : 50 , $lte : 60 } } );</text></choice>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 , $lte : 60 } } );</text></choice>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gte : 50 , $lt : 60 } } );</text></choice>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 } } );</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:tY7I1l8JdDI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Inequalities on strings' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:imCCKOevU3c'/>
</vertical>
<problem showanswer='attempted' url_name='Inequalities_on_strings_problem' rerandomize='never' display_name='Quiz: Inequalities on strings'>
Which of the following will find all users with <em>name</em> between "F" and "Q"?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>db.users.find( { name : { $gte : "F" ,  $lte : "Q" } } );<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.users.find( { name : { $lte : "Q" , $gte : "F" } } );<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.users.find( { name : { $gte : "f" ,  $lte : "Q" } } );<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.users.find( { name :  { $lte : "Q" } });<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ZRWT0lcHsoU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using regexes, $exists, $type' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:lI-jhqYf1JY'/>
</vertical>
<problem showanswer='attempted' url_name='Using_regexes_exists_type_problem' rerandomize='never' display_name='Quiz: Using regexes, $exists, $type'>
Write a query that retrieves documents from a <em>users</em> collection where the <em>name</em> has a "q" in it, and the document has an <em>email</em> field.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.users.find({ name : { $regex : "q" }, email : { $exists: true } } );'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.find({ name : { $regex : "q" }, email : { $exists: true } } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:yMi7PwOoqXY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $or' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:BW5ElNCRZps'/>
</vertical>
<problem showanswer='attempted' url_name='Using_or_problem' rerandomize='never' display_name='Quiz: Using $or'>
How would you find all documents in the <em>scores</em> collection where the <em>score</em> is less than 50 or greater than 90?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.scores.find( { $or : [ { score : { $lt : 50 } }, { score : { $gt : 90 } } ] } ) ;"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find( { $or : [ { score : { $lt : 50 } }, { score : { $gt : 90 } } ] } ) ;'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:diimYkvr374'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $and' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:hYk7pjgjjzc'/>
</vertical>
<problem showanswer='attempted' url_name='Using_and_problem' rerandomize='never' display_name='Quiz: Using $and'>
What will the following query do?

<pre>db.scores.find( { score : { $gt : 50 }, score : { $lt : 60 } } );</pre><choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Find all documents with score between 50 and 60<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Find all documents with score greater than 50<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Find all documents with score less than 60<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Explode like the Death Star<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>None of the above<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:oIkSajy8NLw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Querying inside arrays' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:jvEqwW75Bus'/>
</vertical>
<problem showanswer='attempted' url_name='Querying_inside_arrays_problem' rerandomize='never' display_name='Quiz: Querying inside arrays'>
Which of the following documents would be returned by this query?

<pre>db.products.find( { tags : "shiny" } );</pre><choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>{ _id : 42 , name : "Whizzy Wiz-o-matic", tags : [ "awesome", "shiny" , "green" ] }<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{ _id : 704 , name : "Fooey Foo-o-tron", tags : [ "blue", "mediocre" ] }<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{ _id : 1040 , name : "Snappy Snap-o-lux", tags : "shiny" }<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{ _id : 12345 , name : "Quuxinator", tags : [ ] }<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:gwECaa4N9Xc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $in and $all' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Lv-tYcQfuZg'/>
</vertical>
<problem showanswer='attempted' url_name='Using_in_and_all_problem' rerandomize='never' display_name='Quiz: Using $in and $all'>
Which of the following documents matches this query?

<pre>db.users.find( { friends : { $all : [ "Joe" , "Bob" ] }, favorites : { $in : [ "running" , "pickles" ] } } )</pre><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>{ name : "William" , friends : [ "Bob" , "Fred" ] , favorites : [ "hamburgers", "running" ] }</text></choice>
<choice location='bottom' correct='false'><text>{ name : "Stephen" , friends : [ "Joe" , "Pete" ] , favorites : [ "pickles", "swimming" ] }</text></choice>
<choice location='bottom' correct='true'><text>{ name : "Cliff" , friends : [ "Pete" , "Joe" , "Tom" , "Bob" ] , favorites : [ "pickles", "cycling" ] }</text></choice>
<choice location='bottom' correct='false'><text>{ name : "Harry" , friends : [ "Joe" , "Bob" ] , favorites : [ "hot dogs", "swimming" ] }</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:O8YQRq4vXig'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Queries with dot notation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:NrjFECIfwqk'/>
</vertical>
<problem showanswer='attempted' url_name='Queries_with_dot_notation_problem' rerandomize='never' display_name='Quiz: Queries with dot notation'>
Suppose a simple e-commerce product catalog called <em>catalog</em> with documents that look like this:

<pre>
{ product : "Super Duper-o-phonic", 
  price : 100000000000,
  reviews : [ { user : "fred", comment : "Great!" , rating : 5 },
              { user : "tom" , comment : "I agree with Fred, somewhat!" , rating : 4 } ],
  ... }
</pre>

Write a query that finds all products that cost more than 10,000 and that have a rating of 5 or better.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.catalog.find( { price : { $gt : 10000 } , "reviews.rating" : { $gte : 5 } } ); '> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.catalog.find( { price : { $gt : 10000 } , "reviews.rating" : { $gte : 5 } } ); '''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:yiEjK_V008s'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Querying, cursors' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:3jA6iFSEJOI'/>
</vertical>
<problem showanswer='attempted' url_name='Querying_cursors_problem' rerandomize='never' display_name='Quiz: Querying, cursors'>
Recall the documents in the scores collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

Write a query that retrieves exam documents, sorted by score in descending order, skipping the first 50 and showing only the next 20.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.scores.find( { type : "exam" } ).sort( { score : -1 } ).skip(50).limit(20)'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find( { type : "exam" } ).sort( { score : -1 } ).skip(50).limit(20)'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:djzpK7UIO94'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Counting results' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:eKD5bVmNQMI'/>
</vertical>
<problem showanswer='attempted' url_name='Counting_results_problem' rerandomize='never' display_name='Quiz: Counting results'>
How would you count the documents in the <em>scores</em> collection where the type was "essay" and the score was greater than 90?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.scores.count({ type:"essay", score:{$gt:90}});'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.count({ type:"essay", score:{$gt:90}});'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Uozp0diXOc8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Wholesale Updating of a Document' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:EBCk6W7x-OY'/>
</vertical>
<problem showanswer='attempted' url_name='Wholesale_Updating_of_a_Document_problem' rerandomize='never' display_name='Quiz: Wholesale Updating of a Document'>
Let's say you had a collection with the following document in it:
<pre>
{ "_id" : "Texas", "population" : 2500000, "land_locked" : 1 }
</pre>
and you issued the query:
<pre>
db.foo.update({_id:"Texas"},{population:30000000})
</pre>
What would be the state of the collection after the update?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>{ "_id" : "Texas", "population" : 2500000, "land_locked" : 1 }
</text></choice>
<choice location='bottom' correct='false'><text>{ "_id" : "Texas", "population" : 3000000, "land_locked" : 1 }
</text></choice>
<choice location='bottom' correct='true'><text>{ "_id" : "Texas", "population" : 30000000 }</text></choice>
<choice location='bottom' correct='false'><text>{ "_id" : ObjectId("507b7c601eb13126c9e3dcca"), "population" : 2500000 }</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pwnRUdtI8lY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using the $set command' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:9iMX2KxYAd8'/>
</vertical>
<problem showanswer='attempted' url_name='Using_the_set_command_problem' rerandomize='never' display_name='Quiz: Using the $set command'>
Given the document
<pre>
{'username':'splunker', 'country':'US', 'phone':'718-343-3433'}
</pre>
in the collection <em>users</em>, write the shell command for updating the country to 'RU' for only this user. <customresponse>
<textbox rows='4' cols='50' correct_answer="db.users.update({'username':'splunker'},{$set:{'country':'RU'}})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({'username':'splunker'},{$set:{'country':'RU'}})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:F6ZY_VVAXZ8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using the $unset command' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Kxd4MXBEx-I'/>
</vertical>
<problem showanswer='attempted' url_name='Using_the_unset_command_problem' rerandomize='never' display_name='Quiz: Using the $unset command'>
Write an update query that will unset the <em>interests</em> key in the following document in the collection <em>users</em>.  The primary key is <em>username</em>.
<pre>
{'username':'jimmy', favorite_color:'blue', interests:['debating', 'politics']}
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer="db.users.update({username:'jimmy'}, {$unset:{'interests':1}})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({username:'jimmy'}, {$unset:{'interests':1}})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:edqDAKMQTv4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $push, $pop, $pull, $pushAll, $pullAll, $addToSet' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:iHSwyr7bfQs'/>
</vertical>
<problem showanswer='attempted' url_name='Using_push_pop_pull_pushAll_pullAll_addToSet_problem' rerandomize='never' display_name='Quiz: Using $push, $pop, $pull, $pushAll, $pullAll, $addToSet'>
Suppose you have the following document in your <em>friends</em> collection:

<pre>
{ _id : "Mike", interests : [ "chess", "botany" ] }
</pre>

What will the result of the following updates be?

<pre>
db.friends.update( { _id : "Mike" }, { $push : { interests : "skydiving" } } );
db.friends.update( { _id : "Mike" }, { $pop : { interests : -1 } } );
db.friends.update( { _id : "Mike" }, { $addToSet : { interests : "skydiving" } } );
db.friends.update( { _id : "Mike" }, { $pushAll: { interests : [ "skydiving" , "skiing" ] } } );
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer='{ _id : "Mike" , "interests" : [ "botany", "skydiving", "skydiving", "skiing" ] }'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''{ _id : "Mike" , "interests" : [ "botany", "skydiving", "skydiving", "skiing" ] }'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:bGbiIGEM0FY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Upserts' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:dfvwrlVODGc'/>
</vertical>
<problem showanswer='attempted' url_name='Upserts_problem' rerandomize='never' display_name='Quiz: Upserts'>
After performing the following update on an empty collection
<pre>
db.foo.update({username:'bar'}, {'$set':{'interests':['cat', 'dog']}}, {upsert: true} );
</pre>
What could be the state of the collection.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>{ "_id" : ObjectId("507b78232e8dfde94c149949"), "interests" : [ "cat", "dog" ]}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{"interests" : [ "cat", "dog" ], "username" : "bar" }<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{ "_id" : ObjectId("507b78232e8dfde94c149949"), "interests" : [ "cat", "dog" ], "username" : "bar" }<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Loo5XKQAryM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multi-update' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:8uNNDduO09w'/>
</vertical>
<problem showanswer='attempted' url_name='Multi_update_problem' rerandomize='never' display_name='Quiz: Multi-update'>
Recall the schema of the <em>scores</em> collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

How would you give every record whose score was less than 70 an extra 20 points?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.scores.update( { score : { $lt: 70 } } , { $inc : { score : 20 } } , { multi : true } );"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.update( { score : { $lt: 70 } } , { $inc : { score : 20 } } , { multi : true } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:B1DqIls06Tc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Removing data' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:PMhGgc3HCn4'/>
</vertical>
<problem showanswer='attempted' url_name='Removing_data_problem' rerandomize='never' display_name='Quiz: Removing data'>
Recall the schema of the <em>scores</em> collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

How would you delete every record whose score was less than 60?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.scores.remove( { score : { $lt : 60 } } );"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.remove( { score : { $lt : 60 } } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:T3wcuZHm6Ac'/>
</vertical>
</sequential>
<sequential graded='false' display_name='getLastError'>
<vertical>
<video display_name='Lecture' youtube='1.0:kUulkJQvH_A'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, find, find_one and cursors' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:kXu5V3MlFI0'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_find_find_one_and_cursors_problem' rerandomize='never' display_name='Quiz: Pymongo, find, find_one and cursors'>
In the following code snippet:
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the school database
db=connection.school
scores = db.scores
     
try:
        xxxx
        
except:
        print "Unexpected error:", sys.exc_info()[0]


print doc
</pre>
please enter the one line of python code that would be needed in in place of xxxx to find one document in the collection.<customresponse>
<textbox rows='4' cols='50' correct_answer="doc = scores.find_one()"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''doc = scores.find_one()'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:d-EOPb3_YVI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using field selection' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pCRMWfF_SC8'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_using_field_selection_problem' rerandomize='never' display_name='Quiz: Pymongo, using field selection'>
Which of the following could work using pymongo, depending on variable names, to select out just the student_id from the scores collection using a find command.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>cursor = students.find({'student_id':1, '_id':0})</text></choice>
<choice location='bottom' correct='false'><text>cursor = students.find({'student_id':1})</text></choice>
<choice location='bottom' correct='true'><text>cursor = students.find({}, {'student_id':1, '_id':0})</text></choice>
<choice location='bottom' correct='false'><text>cursor = students.find({}, {student_id:1, _id:0})</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vMNLxyQ47BM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using $gt and $lt' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:p5ltB0g3lUo'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_using_gt_and_lt_problem' rerandomize='never' display_name='Quiz: Pymongo, using $gt and $lt'>
In the following code, what is the correct line of code, marked by xxxx,  to search for all quiz scores that are greater than 20 and less than 90.
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the school database
db=connection.school
scores = db.scores


def find():

    print "find, reporting for duty"

    xxxx

    try:
        iter = scores.find(query)

    except:
        print "Unexpected error:", sys.exc_info()[0]
        
    return iter

find()
</pre>

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text> query = {'score':{'$gt':20, '$lt':90}}</text></choice>
<choice location='bottom' correct='true'><text> query = {'type':'quiz', 'score':{'$gt':20, '$lt':90}}</text></choice>
<choice location='bottom' correct='false'><text> query = {'type':'quiz', '$gt':{'score':20}, '$lt':{'score':90}}</text></choice>
<choice location='bottom' correct='false'><text> query = {'type':'quiz', 'score':{$gt:20, $lt:90}}</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:2kzdSZmJ8jM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Importing from Reddit'>
<vertical>
<video display_name='Lecture' youtube='1.0:dd49ULz7y6Q'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using a regex'>
<vertical>
<video display_name='Lecture' youtube='1.0:UIes2_2rBWE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using dot notation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:kiJRqBbCSGk'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_using_dot_notation_problem' rerandomize='never' display_name='Quiz: Pymongo, using dot notation'>
In the following code, what do you think will happen if a document that matches the query doesn't have a key called <i>media.oembed.url</i>?
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the reddit database
db=connection.reddit
scores = db.stories


def find():

    print "find, reporting for duty"

    query = {'media.oembed.type':'video'}
    projection = {'media.oembed.url':1, '_id':0}

    try:
        iter = scores.find(query, projection)

    except:
        print "Unexpected error:", sys.exc_info()[0]

    sanity = 0
    for doc in iter:
        print doc
        sanity += 1
        if (sanity > 10):
            break
        

find()

</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Pymongo will throw an exception.</text></choice>
<choice location='bottom' correct='true'><text>Pymongo will return an empty document</text></choice>
<choice location='bottom' correct='false'><text>Pymongo will return a document with the following structure {media:{oembed:{url:{}}}}</text></choice>
<choice location='bottom' correct='false'><text>There is not enough information to know</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:5mpm64vncL0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, sort, skip and limit' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:F1bSsbt5Qfk'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_sort_skip_and_limit_problem' rerandomize='never' display_name='Quiz: Pymongo, sort, skip and limit'>
Supposed you had the following documents in a collection named things.
<pre>
{ "_id" : 0, "value" : 10 }
{ "_id" : 2, "value" : 5 }
{ "_id" : 3, "value" : 7 }
{ "_id" : 4, "value" : 20 }
</pre>
If you performed the following query in pymongo:
<pre>
cursor = things.find().skip(3).limit(1).sort('value",pymongo.DESCENDING)
</pre>
which document would be returned?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>The document with _id=0</text></choice>
<choice location='bottom' correct='true'><text>The document with _id=2</text></choice>
<choice location='bottom' correct='false'><text>The document with _id=3</text></choice>
<choice location='bottom' correct='false'><text>The doucment with _id=4</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cUNoJN6Ii-I'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, Sort, final thoughts'>
<vertical>
<video display_name='Lecture' youtube='1.0:hwUg8r7a-d8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, Inserting' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:1buD4Ern9rA'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_Inserting_problem' rerandomize='never' display_name='Quiz: Pymongo, Inserting'>
Do you expect the second insert below to succeed?
<pre>

# get a handle to the school database
db=connection.school
people = db.people

doc = {"name":"Andrew Erlichson", "company":"10gen",
              "interests":['running', 'cycling', 'photography']}

try:
        people.insert(doc)   # first insert
        del(doc['_id'])
        people.insert(doc)   # second insert

except:
        print "Unexpected error:", sys.exc_info()[0]

</pre><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>No, because the _id will be a duplicate in the collection</text></choice>
<choice location='bottom' correct='false'><text>No, because the del call will delete the entire record in python</text></choice>
<choice location='bottom' correct='true'><text>Yes, because the del call will remove the _id key added by the pymongo driver in the first insert</text></choice>
<choice location='bottom' correct='false'><text>Yes, because the pymongo driver always adds a unique _id field on insert.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pEMyrKDzgFg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, Updating' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:u6iRURy8rY0'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_Updating_problem' rerandomize='never' display_name='Quiz: Pymongo, Updating'>
In the following code fragment, what is the python expression in place of xxxx to set a new key "examiner" to be "Jones"

Please use the $set operator

<pre>

def using_set():

    print "updating record using set"
    # get a handle to the school database
    db=connection.school
    scores = db.scores


    try:
        # get the doc
        score = scores.find_one({'student_id':1, 'type':'homework'})
        print "before: ", score

        # update using set
        scores.update({'student_id':1, 'type':'homework'},
                      xxxx)

        score = scores.find_one({'student_id':1, 'type':'homework'})
        print "after: ", score

    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise

</pre>
<customresponse>
<textbox rows='4' cols='50' correct_answer="{'$set':{'examiner':'Jones'}}"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''{'$set':{'examiner':'Jones'}}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Cyk5uzO-65w'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, upserts' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:hcGo9lV9HwI'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_upserts_problem' rerandomize='never' display_name='Quiz: Pymongo, upserts'>
Suppose we would like to upsert the following document into the collection <i>stuff</i>:
<pre>
{_id:"bat", friend:'ball', cousin:'glove'}
</pre>
Which of the following python statements work. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>stuff.update({'_id':'bat'},  {'friend':'ball', 'cousin':'glove'}, upsert=True)<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>stuff.update({'_id':'bat'},  {'friend':'ball', 'cousin':'glove'}, upsert=False)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>stuff.update({'_id':'bat'},  {'_id':'bat', 'friend':'ball', 'cousin':'glove'}, upsert=True)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>stuff.update({'_id':'bat'},  {'$set': {'friend':'ball', 'cousin':'glove'}}, upsert=True)<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:tMEohyZX0cI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, find_and_modify'>
<vertical>
<video display_name='Lecture' youtube='1.0:rQ8Oml5e6PI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog, User Interface'>
<vertical>
<video display_name='Lecture' youtube='1.0:QA80WBg0hLg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog, Session Management'>
<vertical>
<video display_name='Lecture' youtube='1.0:sNigml3JoY0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog, Internals'>
<vertical>
<video display_name='Lecture' youtube='1.0:tTqQZvBGhyU'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.1' format='Homework' due='Nov 9 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_1_problem' rerandomize='never' display_name='Quiz: Homework 2.1'>
In this problem, you will be using a collection of student scores that is similar to what we used in the lessons. Please download the <a href="/static/handouts/grades.js">grades.js</a> file and import it into your local mongo database as follows:
<pre>
mongoimport -d students -c grades &lt; grades.js
</pre>
The dataset contains 4 scores for 200 students.
<p>
First, letâ€™s confirm your data is intact; the number of documents should be 800.
</p>
<pre>
> use students
> db.grades.count()
800
</pre>
<p>
This next query, which uses the aggregation framework that we have not taught yet, will tell you the <em>student_id</em> with the highest average score:
</p>

<pre>
> db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>
<b><i>Note:  Aggregation requires <a href="http://www.mongodb.org/downloads">mongodb 2.2</a> or above.</i></b>

<p>
The answer, deep in the resulting document, should be <em>student_id</em> 164 with an average of approximately 89.3.
</p>

Now itâ€™s your turn to analyze the data set. Find all exam scores greater than or equal to 65. and sort those scores from lowest to highest.
<p>What is the <em>student_id</em> of the lowest exam score above 65?</p>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>115</text></choice>
<choice location='bottom' correct='true'><text>22</text></choice>
<choice location='bottom' correct='false'><text>48</text></choice>
<choice location='bottom' correct='false'><text>57</text></choice>
<choice location='bottom' correct='false'><text>87</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:RUy50I3mrnU'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.2' format='Homework' due='Nov 9 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_2_problem' rerandomize='never' display_name='Quiz: Homework 2.2'>
<p>
Write a program in the language of your choice that will remove the grade of type "homework" with the lowest score for each student from the <a href="/static/handouts/grades.js">dataset</a> that you imported in HW 2.1.  Since each document is one grade, it should remove one document per student.
</p>
<p>
<i>Hint/spoiler</i>: If you select homework grade-documents, sort  by student and then by score, you can iterate through and find the lowest score for each student by noticing a change in student id. As you notice that change of student_id, remove the document.
</p>

<p>
To confirm you are on the right track, here are some queries to run after you process the data with the correct answer shown:
</p>

Let us count the number of grades we have:
<pre>
> db.grades.count() 
600
</pre>

Now let us find the student who holds the 101st best grade across all grades:
<pre>
> db.grades.find().sort({'score':-1}).skip(100).limit(1)
{ "_id" : ObjectId("50906d7fa3c412bb040eb709"), "student_id" : 100, "type" : "homework", "score" : 88.50425479139126 }
</pre>

Now let us sort the students by student_id, score and see what the top five docs are:
<pre>
> db.grades.find({},{'student_id':1, 'type':1, 'score':1, '_id':0}).sort({'student_id':1, 'score':1, }).limit(5)
{ "student_id" : 0, "type" : "quiz", "score" : 31.95004496742112 }
{ "student_id" : 0, "type" : "exam", "score" : 54.6535436362647 }
{ "student_id" : 0, "type" : "homework", "score" : 63.98402553675503 }
{ "student_id" : 1, "type" : "homework", "score" : 44.31667452616328 }
{ "student_id" : 1, "type" : "exam", "score" : 74.20010837299897 }
</pre>

<p>
To verify that you have completed this task correctly, provide the identify of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document. 
</p>
<pre>
> db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>

Enter the student ID below. Please enter just the number, with no spaces, commas or other characters.<customresponse>
<textbox rows='4' cols='50' correct_answer="54"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''54'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:xS0njlIkClY'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.3' format='Homework' due='Nov 9 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_3_problem' rerandomize='never' display_name='Quiz: Homework 2.3'>
<em>Blog User Sign-up and Login</em>
<p>
Download <a href="/static/handouts/hw2.3.zip">hw2.3.zip</a> or <a href="/static/handouts/hw2.3.tar">hw2.3.tar</a> and unpack.
</p>
<p>
You should see two files at the highest level: <i>blog.py</i> and <i>user.py</i>. There is also a views directory which contains the templates for the project. 
</p>
<p>
The project roughly follows the model/view/controller paradigm. <i>user.py</i> is the model. <i>blog.py</i> is the controller.  The templates comprise the view.
</p>

<p>
If everything is working properly, you should be able to start the blog by typing:
</p>
<pre>
python blog.py
</pre>

<p>
Note that this project requires the following python modules be installed on your computer: cgi, hmac, re, datetime, random, json, sys, string, hashlib, bson, urllib, urllib2, random, re, pymongo, and bottle. A typical Python installation will already have most of these installed except <i>pymongo</i> and <i>bottle</i>.
</p>
<p>
If you have python-setuptools installed, the command "easy_install" makes this simple.  Any other missing packages will show up when <i>validate.py</i> is run, and can be installed in a similar fashion.
</p>
<pre>
$ easy_install pymongo bottle
</pre>
<p>
If you goto <a href="http://localhost:8082/">http://localhost:8082</a> you should see a message â€œthis is a placeholder for the blogâ€
</p>

<p>
Here are some URLs that must work when you are done.
</p>
<pre>
http://localhost:8082/signup
http://localhost:8082/login
http://localhost:8082/logout
</pre>

<p>
When you login or sign-up, the blog will redirect to 
http://localhost:8082/welcome
and that must work properly, welcoming the user by username
</p>
<p>
We have removed two pymongo statements from user.py and marked the area where you need to work with XXX. You should not need to touch any other code.  The pymongo statements that you are going to add will add a new user upon sign-up and validate a login by retrieving the right user document. 
</p>
<p>
The blog stores its data in the blog database in two collections, <i>users</i> and <i>sessions</i>.  Here are two example docs for a username â€˜erlichsonâ€™ with password â€˜fubarâ€™. You can insert these if you like, but you donâ€™t need to.
</p>
<pre>
> db.users.find()
{ "_id" : "erlichson", "password" : "d3caddd3699ef6f990d4d53337ed645a3804fac56207d1b0fa44544db1d6c5de,YCRvW" }
> 
> db.sessions.find()
{ "_id" : ObjectId("50907cda49037223b802117d"), "username" : "erlichson" }
> 
</pre>

<p>
Once you have the the project working, the following steps should work:
</p>
<ul>
<li>go to http://localhost:8082/signup</li>
<li>create a user</li>
</ul>
It should redirect you to the welcome page and say: welcome username, where username is the user you signed up with.  Now
<ul>
<li>Goto http://localhost:8082/logout</li>
<li>Now login http://localhost:8082/login.</li>
</ul>
<br/>
<p>
Ok, now itâ€™s time to validate you got it all working.
</p>
<p>
There was one additional program that should have been downloaded in the project called <i>validate.py</i>.
</p>
<pre>
python validate.py
</pre>
If you got it right, it will provide a validation code for you to enter into the box below. Enter just the code, no spaces.
<customresponse>
<textbox rows='4' cols='50' correct_answer="h726dgdf63289wjaklf9467ghdsjkf"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''h726dgdf63289wjaklf9467ghdsjkf'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:94YWxpX3w-c'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-11-09T00:00' display_name='Week 3 - Schema Design'>
<sequential graded='false' display_name='Introduction to Week 3' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:itnfWjMnQ4A'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_Week_3_problem' rerandomize='never' display_name='Quiz: Introduction to Week 3'>
What's the single most important factor in designing your application schema within MongoDB?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Making the design extensible.</text></choice>
<choice location='bottom' correct='false'><text>Making it easy to read by a human.</text></choice>
<choice location='bottom' correct='true'><text>Matching the data access patterns of your application.</text></choice>
<choice location='bottom' correct='false'><text>Keeping the data in third normal form.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:OVDnLJXpqNE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Relational Normalization'>
<vertical>
<video display_name='Lecture' youtube='1.0:GX__f2s4hd8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo Design for Blog' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:PRylEHH5t84'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_Design_for_Blog_problem' rerandomize='never' display_name='Quiz: Mongo Design for Blog'>
Which data access pattern is not well supported by the blog schema?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Collecting the most recent blog entries for the blog home page</text></choice>
<choice location='bottom' correct='false'><text>Collecting all the information to display a single post</text></choice>
<choice location='bottom' correct='false'><text>Collecting all comments by a single author</text></choice>
<choice location='bottom' correct='true'><text>Providing a table of contents by tag</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:s5E0T4caqj4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Alternative Schema for Blog'>
<vertical>
<video display_name='Lecture' youtube='1.0:ZvqNWVWB2-o'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Living Without Constraints' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:YFRMkDPaams'/>
</vertical>
<problem showanswer='attempted' url_name='Living_Without_Constraints_problem' rerandomize='never' display_name='Quiz: Living Without Constraints'>
What does Living Without Constraints refer to?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Living every day like it's your last</text></choice>
<choice location='bottom' correct='false'><text>Saying whatever you want when you want it</text></choice>
<choice location='bottom' correct='true'><text>Keeping your data consistent even though MongoDB lacks foreign key constraints</text></choice>
<choice location='bottom' correct='false'><text>Wearing no belt</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:3VckBMGInic'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Living without Transactions' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:FfRr3qjRfww'/>
</vertical>
<problem showanswer='attempted' url_name='Living_without_Transactions_problem' rerandomize='never' display_name='Quiz: Living without Transactions'>
Which of the following operations operate atomically within a single document? Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Update<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>findAndModify<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>$addToSet (within an update)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>$push within an update<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:189zABW3HHk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='One to One Relations' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:cCsfon0vUlQ'/>
</vertical>
<problem showanswer='attempted' url_name='One_to_One_Relations_problem' rerandomize='never' display_name='Quiz: One to One Relations'>
What's a good reason you might want to keep two documents that are related to each other one-to-one in separate collections? Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Because you want to allow atomic update of both documents at once.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>To reduce the working set size of your application.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>To enforce foreign key constraints<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Because the combined size of the documents would be larger than 16MB<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:BjW64RkzlGg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='One To Many Relations' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:EIaP1KbVkUc'/>
</vertical>
<problem showanswer='attempted' url_name='One_To_Many_Relations_problem' rerandomize='never' display_name='Quiz: One To Many Relations'>
When is it recommended to represent a one to many relationship in multiple collections?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Always</text></choice>
<choice location='bottom' correct='true'><text>Whenever the many is large</text></choice>
<choice location='bottom' correct='false'><text>Whenever the many is actually few</text></choice>
<choice location='bottom' correct='false'><text>Never</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:KQcspnr-Y2M'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Many to Many Relations'>
<vertical>
<video display_name='Lecture' youtube='1.0:fEYYjZ7zEHc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multikeys'>
<vertical>
<video display_name='Lecture' youtube='1.0:ocU9WNUL9YQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Benefits of Embedding'>
<vertical>
<video display_name='Lecture' youtube='1.0:XIN0Dqht08Q'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Trees' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:lIjXyQklGWY'/>
</vertical>
<problem showanswer='attempted' url_name='Trees_problem' rerandomize='never' display_name='Quiz: Trees'>
Given the following typical document for a e-commerce category hierarchy collection called <em>categories</em>
<pre>
{
  _id: 34,
  name : "Snorkeling",
  parent_id: 12,
  ancestors: [12, 35, 90]
}
</pre>
Which query will find all descendants of  the snorkeling category?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>db.categories.find({ancestors:{'$in':[12,35,90]}})</text></choice>
<choice location='bottom' correct='false'><text>db.categories.find({parent_id: 34})</text></choice>
<choice location='bottom' correct='false'><text>db.categories.find({_id:{'$in':[12,35,90]}})</text></choice>
<choice location='bottom' correct='true'><text>db.categories.find({ancestors:34})</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:80P6yVSkKQY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='When to Denormalize'>
<vertical>
<video display_name='Lecture' youtube='1.0:jDZ-HFoJ0vg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Handling Blobs'>
<vertical>
<video display_name='Lecture' youtube='1.0:AsL5p1Z0Ss8'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 3.1' format='Homework' due='Nov 19 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:lpSMbphEl7c'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_3_1_problem' rerandomize='never' display_name='Quiz: HW 3.1'>
Download the <a href="/static/handouts/students.js">students.js</a> file to your computer and import it into your local Mongo instance with this command:
<pre>
$ mongoimport -d school -c students &lt; students.js
</pre>
<p>
This dataset holds the same type of data as last week's grade collection, but it's modeled differently. You might want to start by inspecting it in the Mongo shell.
</p><p>
Write a program in the language of your choice that will remove the lowest homework score for each student. Since there is a single document for each student containing an array of scores, you will need to update the scores array and remove the homework.
</p><p>
Hint/spoiler: With the new schema, this problem is a lot harder and that is sort of the point. One way is to find the lowest homework in code and then update the scores array with the low homework pruned. If you are struggling with the Python side of this, look at the remove operator, which can remove stuff from a Python list.
</p><p>
To confirm you are on the right track, here are some queries to run after you process the data with the correct answer shown:
</p><p>

Let us count the number of students we have:
</p>
<pre>
> use school
> db.students.count() 
200
</pre>

Let's see what Demarcus Audette's record looks like:
<pre>
&gt; db.students.find({_id:100}).pretty()
{
	"_id" : 100,
	"name" : "Demarcus Audette",
	"scores" : [
		{
			"score" : 47.42608580155614,
			"type" : "exam"
		},
		{
			"score" : 44.83416623719906,
			"type" : "quiz"
		},
		{
			"score" : 39.01726616178844,
			"type" : "homework"
		}
	]
}

</pre>
<p>
To verify that you have completed this task correctly, provide the identify of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document.
</p>
<pre>
&gt; db.students.aggregate({'$unwind':'$scores'},{'$group':{'_id':'$_id', 'average':{$avg:'$scores.score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>

<customresponse>
<textbox rows='4' cols='50' correct_answer="13"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''13'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='HW 3.2' format='Homework' due='Nov 19 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:SEh6Y4lHkWQ'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_3_2_problem' rerandomize='never' display_name='Quiz: HW 3.2'>
<b>Making your blog accept posts</b>
<p>In this homework you will be enhancing the blog project to insert entries into the posts collection. After this, the blog will work. It will allow you to add blog posts with a title, body and tags and have it be added to the posts collection properly.
</p><p>We have provided the code that creates users and allows you to login (the assignment from last week). To get started, please download <a href="/static/handouts/hw3-blog.tar">hw3-blog.tar</a> or <a href="/static/handouts/hw3-blog.zip">hw3-blog.zip</a> and unpack. You will be using these file for this homework and the HW 3.3.
</p><p>
The areas where you need to add code are marked with XXX.  You need only touch the blog.py file.  There are three locations for you to add code for this problem. Scan that file for XXX to see where to work.
</p>
As a reminder, to run your blog you type<br/>
<pre>
python blog.py
</pre>
To play with the blog you can navigate to the following URLs<br/>
<pre>
http://localhost:8082/
http://localhost:8082/signup
http://localhost:8082/login
http://localhost:8082/newpost
</pre>
You will be proving that it works by running our validation script as follows:
<br/>
<pre>
python validate.py
</pre>
<p>
You need to run this in a separate terminal window while your blog is running and while the database is running. It makes connections to both to determine if your program works properly. Validate connects to localhost:8082 and expects that mongod is running on localhost on port 27017.
</p><p>
<i>Read if you want to run your blog on non-standard port, different host or connected to a mongod on  different server.</i>
</p><p>
<font size="-1">By popular demand, validate.py now takes some optional arguments that you can discover with the -h flag. These arguments will allow you to direct validate.py to make a connection to a web server at different port on a different host and connect to a mongod on a different host. You can also use a database name other than blog, a necessity if you are running on the free tier at MongoHW (for eg). I won't go into how these arguments work, as they are pretty self documenting. Note that to run the blog.py code to connect to a database outside of localhost (for example to a database at MongoHQ), you will need to make some global changes. </font>
</p><p>
This project requires Python 2.7. The code is not 3.0 compliant. 
</p><p>
Ok, once you get the blog posts working, validate.py will print out a validation code for HW 3.2. Please enter it below, exactly as shown with no spaces.
</p>
<customresponse>
<textbox rows='4' cols='50' correct_answer="hjkfd489hjkfhds8934kf23"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''hjkfd489hjkfhds8934kf23'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='HW 3.3' format='Homework' due='Nov 19 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:HPSgVT2BEYQ'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_3_3_problem' rerandomize='never' display_name='Quiz: HW 3.3'>
<b>Making your blog accept comments</b>
<p>
In this homework  you will add code to your blog so that it accepts comments. You will be using the same code as you downloaded for HW 3.2.
</p><p>
Once again, the area where you need to work is marked with an XXX in the blog.py file. There are two locations. You don't need to figure out how to retrieve comments for this homework because the code you did in 3.2 already pulls the entire blog post (unless you specifically projected to eliminate the comments) and we gave you the code that pulls them out of the JSON document.
</p><p>
This assignment has fairly little code, but it's a little more subtle than the previous assignment because you are going to be manipulating an array within the Mongo document.  For the sake of clarity, here is a document out of the posts collection from a working project.
</p>
<pre>
{
	"_id" : ObjectId("509df76fbcf1bf5b27b4a23e"),
	"author" : "erlichson",
	"body" : "This is a blog entry",
	"comments" : [
		{
			"body" : "This is my comment",
			"author" : "Andrew Erlichson"
		},
		{
			"body" : "Give me liberty or give me death.",
			"author" : "Patrick Henry"
		}
	],
	"date" : ISODate("2012-11-10T06:42:55.733Z"),
	"permalink" : "This_is_a_blog_post_title",
	"tags" : [
		"cycling",
		"running",
		"swimming"
	],
	"title" : "This is a blog post title"
}
</pre>

<p>
Note that you add comments in this blog from the blog post detail page, which appears at 
<pre>
http://localhost:8082/post/post_slug
</pre>
where post_slug is the permalink. For the sake of eliminating doubt, the permalink for the example blog post above is http://localhost:8082/post/This_is_a_blog_post_title
</p><p>
You will run validation.py to check your work, much like the last problem. Validation.py will run through and check the requirements of HW 3.2 and then will check to make sure it can add blog comments, as required by this problem, HW 3.3. It checks the web output as well as the database documents.
</p>
<pre>
python validate.py
</pre>
<p>
Once you have the validation code, please copy and paste in the box below, no spaces. 
</p>
<customresponse>
<textbox rows='4' cols='50' correct_answer="dhfr48nf89jk093f9kj0d2d"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''dhfr48nf89jk093f9kj0d2d'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
</chapter>
<chapter start='2012-11-19T00:00' display_name='Week 4 - Performance'>
<sequential graded='false' display_name='Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:MA0QpaGggY8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Indexes' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pPnRWpL5zl4'/>
</vertical>
<problem showanswer='attempted' url_name='Indexes_problem' rerandomize='never' display_name='Quiz: Indexes'>
Which optimization will typically have the greatest impact on the performance of a database.
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Adding more memory so that the working set fits in memory.
</text></choice>
<choice location='bottom' correct='false'><text>Adding a faster drive so that operations that hit disk will happen more quickly.
</text></choice>
<choice location='bottom' correct='false'><text>Replacing your CPU with a faster one (say one 2x as fast)
</text></choice>
<choice location='bottom' correct='true'><text>Adding appropriate indexes on large collections so that only a small percentage of queries need to scan the collection.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:5Z6V8mJ8eS4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Creating Indexes' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:tRqenx45UAM'/>
</vertical>
<problem showanswer='attempted' url_name='Creating_Indexes_problem' rerandomize='never' display_name='Quiz: Creating Indexes'>
Please provide the mongo shell command to add an index to a collection named <i>students</i>, having the index  key be <i>class</i>, <i>student_name</i>. <customresponse>
<textbox rows='4' cols='50' correct_answer="db.students.ensureIndex({class:1, student_name:1})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.students.ensureIndex({class:1, student_name:1})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:h1VdrcOjFm8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Discovering indexes'>
<vertical>
<video display_name='Lecture' youtube='1.0:hH7kYu_-FXg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multikey Indexes' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:JO_puGONaLc'/>
</vertical>
<problem showanswer='attempted' url_name='Multikey_Indexes_problem' rerandomize='never' display_name='Quiz: Multikey Indexes'>
Suppose we have a collection <i>foo</i> that has an index created as follows:
<pre>
db.foo.ensureIndex({a:1, b:1})
</pre>
Which of the following inserts are valid to this collection?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>db.foo.insert({a:["apples","oranges"], b:"grapes"})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.insert({a:"grapes", b:"oranges"})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.insert({a:"grapes", b:[8,9,10]})<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.foo.insert({a:[1,2,3], b:[5,6,7]})<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:CeE6hZ90Uzk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multikey Continued'>
<vertical>
<video display_name='Lecture' youtube='1.0:mPSGG2p33RQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation option, Unique' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:764mQG1iL8E'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_option_Unique_problem' rerandomize='never' display_name='Quiz: Index Creation option, Unique'>
Please provide the mongo shell command to add a unique index to the collection <i>students</i> on the keys <i>student_id</i>, <i>class_id</i>.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.students.ensureIndex({student_id:1, class_id:1}, {unique:true})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.students.ensureIndex({student_id:1, class_id:1}, {unique:true})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cCO7b-fcj0I'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation, Removing Dups' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:YJaWPXNGvoU'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_Removing_Dups_problem' rerandomize='never' display_name='Quiz: Index Creation, Removing Dups'>
If you choose the dropDups option when creating a unique index, what will the MongoDB do to documents that conflict with an existing index entry? <multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Move them to an archive collection.</text></choice>
<choice location='bottom' correct='false'><text>Unset the conflicting key so that they can be indexed and remain in the collection.</text></choice>
<choice location='bottom' correct='false'><text>Remove them but write the deleted documents in JSON to a special file in the log directory.</text></choice>
<choice location='bottom' correct='true'><text>Delete them for ever and ever, Amen.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:s46y1rJAvVs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation, Sparse' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:s4sYwLndtTI'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_Sparse_problem' rerandomize='never' display_name='Quiz: Index Creation, Sparse'>
Suppose you had the following documents in a collection called <i>people</i> with the following docs:
<pre>
> db.people.find()
{ "_id" : ObjectId("50a464fb0a9dfcc4f19d6271"), "name" : "Andrew", "title" : "Jester" }
{ "_id" : ObjectId("50a4650c0a9dfcc4f19d6272"), "name" : "Dwight", "title" : "CEO" }
{ "_id" : ObjectId("50a465280a9dfcc4f19d6273"), "name" : "John" }
</pre>
And there is an index defined as follows:
<pre>
db.people.ensureIndex({title:1}, {sparse:1})
</pre>
If you perform the following query, what do you get back, and why?
<pre>
db.people.find({title:null})
</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>No documents, because the query uses the index and there are no documents with title:null in the index.</text></choice>
<choice location='bottom' correct='false'><text>No documents, because querying for title:null only finds documents that explicitly have title:null, regardless of the index.</text></choice>
<choice location='bottom' correct='false'><text>The document for John, because the query won't use the index. </text></choice>
<choice location='bottom' correct='false'><text>All the documents in the collection, because title:null matches all documents.</text></choice>
<choice location='bottom' correct='false'><text>The document for John, because the ensureIndex command won't succeed in this case.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:_MJYRlianas'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation, Background' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:28wCvoXmY7A'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_Background_problem' rerandomize='never' display_name='Quiz: Index Creation, Background'>
Which things are true about creating an index in the background in MongoDB. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>A mongod instance can only build one background index at a time per database.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Although the database server will continue to take requests, a background index creation still blocks the mongo shell that you are using to create the index.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Creating an index in the background takes longer than creating it in the foreground<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>In Mongo 2.2 and above, indexes are created in the background by default.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:aNSHjG_LnSc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using Explain' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:inmABt5RKf0'/>
</vertical>
<problem showanswer='attempted' url_name='Using_Explain_problem' rerandomize='never' display_name='Quiz: Using Explain'>
Given the following output from explain, what is the best description of what happened during the query?
<pre>
{
	"cursor" : "BasicCursor",
	"isMultiKey" : false,
	"n" : 100000,
	"nscannedObjects" : 10000000,
	"nscanned" : 10000000,
	"nscannedObjectsAllPlans" : 10000000,
	"nscannedAllPlans" : 10000000,
	"scanAndOrder" : false,
	"indexOnly" : false,
	"nYields" : 7,
	"nChunkSkips" : 0,
	"millis" : 5151,
	"indexBounds" : {
		
	},
	"server" : "Andrews-iMac.local:27017"
}

</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>The query used an index called BasicCursor and returned in a 5151 microseconds</text></choice>
<choice location='bottom' correct='true'><text>The query scanned 10,000,000 documents, returning 100,000 in 5.2 seconds.</text></choice>
<choice location='bottom' correct='false'><text>The query scanned 100,000 documents and return in 5 milliseconds.</text></choice>
<choice location='bottom' correct='false'><text>The query was able to use a covered index to answer the query entirely within the index without looking at the documents.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Gpj_s49H_rQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='When is an index used?' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Lwms58Y_3Jc'/>
</vertical>
<problem showanswer='attempted' url_name='When_is_an_index_used__problem' rerandomize='never' display_name='Quiz: When is an index used?'>
Given collection foo with the following index:
<pre>
db.foo.ensureIndex({a:1, b:1, c:1})
</pre>
Which of the following queries will use the index?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>db.foo.find({b:3, c:4})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.find({a:3})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.find({c:1}).sort({a:1, b:1})<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.foo.find({c:1}).sort({a:-1, b:1})<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:imHqsvqx-GA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='How large is your index?' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:oywrqWNY46s'/>
</vertical>
<problem showanswer='attempted' url_name='How_large_is_your_index__problem' rerandomize='never' display_name='Quiz: How large is your index?'>
Is it more important that your index or your data fit into memory?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>Index</text></choice>
<choice location='bottom' correct='false'><text>Data</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:mXHUIghDkFw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Cardinality' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:xiujksUfzUA'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Cardinality_problem' rerandomize='never' display_name='Quiz: Index Cardinality'>
Let's say you update a document with a key called tags and that update causes the document to need to get moved on disk. If the document has 100 tags in it, and if the tags array is indexed with a multikey index, how many index points need to be updated in the index to accomodate the move? Put just the number below.<customresponse>
<textbox rows='4' cols='50' correct_answer="100"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''100'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4UW_oMSswTo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Selectivity' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:On8HHR1agsI'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Selectivity_problem' rerandomize='never' display_name='Quiz: Index Selectivity'>
Given the following attributes of automobiles: color, weight, manufacturer, odometer mileage, which index is likely be the most selective, provided you can provide all four attributes on a search:<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Color</text></choice>
<choice location='bottom' correct='false'><text>Weight</text></choice>
<choice location='bottom' correct='false'><text>Manufacturer</text></choice>
<choice location='bottom' correct='true'><text>Odometer Mileage</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:BT95omWR2nw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hinting an Index' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ksOn-SkaIcg'/>
</vertical>
<problem showanswer='attempted' url_name='Hinting_an_Index_problem' rerandomize='never' display_name='Quiz: Hinting an Index'>
Given the following data in a collection:
<pre>
> db.people.find()
{ "_id" : ObjectId("50a464fb0a9dfcc4f19d6271"), "name" : "Andrew", "title" : "Jester" }
{ "_id" : ObjectId("50a4650c0a9dfcc4f19d6272"), "name" : "Dwight", "title" : "CEO" }
{ "_id" : ObjectId("50a465280a9dfcc4f19d6273"), "name" : "John" }
</pre>
and the following indexex:
<pre>
> db.people.getIndexes()
[
	{
		"v" : 1,
		"key" : {
			"_id" : 1
		},
		"ns" : "test.people",
		"name" : "_id_"
	},
	{
		"v" : 1,
		"key" : {
			"title" : 1
		},
		"ns" : "test.people",
		"name" : "title_1",
		"sparse" : 1
	}
]
</pre>
Which query below will return the most documents.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>db.people.find().sort({'title':1}).hint({$natural:1})</text></choice>
<choice location='bottom' correct='false'><text>db.people.find().sort({'title':1})</text></choice>
<choice location='bottom' correct='false'><text>db.people.find({name:{$ne:"Kevin"}}).sort({'title':1})</text></choice>
<choice location='bottom' correct='false'><text>db.people.find({'title':{$ne:null}}).hint({'title':1})
</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:WHc_qRSxGM0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hinting in Pymongo'>
<vertical>
<video display_name='Lecture' youtube='1.0:dlKcfo7WtGU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Efficiency of Index Use'>
<vertical>
<video display_name='Lecture' youtube='1.0:1sADN-NKwhY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Geospatial Indexes' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:UKUDYqNVL6I'/>
</vertical>
<problem showanswer='attempted' url_name='Geospatial_Indexes_problem' rerandomize='never' display_name='Quiz: Geospatial Indexes'>
Suppose you have a 2D geospatial index defined on the key <i>location</i> in the collection <i>places</i>. Write a query that will find the closest three places (the closest three documents) to the location 74, 140.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.places.find( { location : { $near : [74,140] } }).limit(3)&#10;"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.places.find( { location : { $near : [74,140] } }).limit(3)
'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:hVLa0H7Oe98'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Geospacial Spherical'>
<vertical>
<video display_name='Lecture' youtube='1.0:vY3_H4MzkIY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Logging Slow Queries'>
<vertical>
<video display_name='Lecture' youtube='1.0:aWuvC-O7Qkk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Profiling' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pN1Yhrup9-I'/>
</vertical>
<problem showanswer='attempted' url_name='Profiling_problem' rerandomize='never' display_name='Quiz: Profiling'>
Write the query to look in the system profile collection for all queries that took longer than one second, ordered by timestamp descending.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.system.profile.find({millis:{$gt:1000}}).sort({ts:-1})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.system.profile.find({millis:{$gt:1000}}).sort({ts:-1})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:A4x4kE02pSc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongotop'>
<vertical>
<video display_name='Lecture' youtube='1.0:D9YLXgy7NYo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongostat'>
<vertical>
<video display_name='Lecture' youtube='1.0:eLWQO_AJmrI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Sharding Overview'>
<vertical>
<video display_name='Lecture' youtube='1.0:BDxT-VZdYqc'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 4.1' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_4_1_problem' rerandomize='never' display_name='Quiz: HW 4.1'>
Suppose you have a collection with the following indexes:
<pre>
> db.products.getIndexes()
[
	{
		"v" : 1,
		"key" : {
			"_id" : 1
		},
		"ns" : "store.products",
		"name" : "_id_"
	},
	{
		"v" : 1,
		"key" : {
			"sku" : 1,
			"unique" : true
		},
		"ns" : "store.products",
		"name" : "sku_1_unique_true"
	},
	{
		"v" : 1,
		"key" : {
			"price" : -1
		},
		"ns" : "store.products",
		"name" : "price_-1"
	},
	{
		"v" : 1,
		"key" : {
			"description" : 1
		},
		"ns" : "store.products",
		"name" : "description_1"
	},
	{
		"v" : 1,
		"key" : {
			"category" : 1,
			"brand" : 1
		},
		"ns" : "store.products",
		"name" : "category_1_brand_1"
	},
	{
		"v" : 1,
		"key" : {
			"reviews.author" : 1
		},
		"ns" : "store.products",
		"name" : "reviews.author_1"
	}

</pre>
Which of the following queries can utilize an index. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>db.products.find({'brand':"GE"})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.products.find({'brand':"GE"}).sort({price:1})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.products.find({$and:[{price:{$gt:30}},{price:{$lt:50}}]}).sort({brand:1})<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.products.find({brand:'GE'}).sort({category:1, brand:-1}).explain()<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='HW 4.2' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_4_2_problem' rerandomize='never' display_name='Quiz: HW 4.2'>
Suppose you have a collection called <i>tweets</i> whose documents contain information about the created_at time of the tweet, and the user's follower count at the time they issued the tweet. What can you infer from the following <i>explain</i> output?

<pre>
db.tweets.find({"user.followers_count":{$gt:1000}}).sort({"created_at" : 1 }).limit(10).skip(5000).explain()
{
        "cursor" : "BtreeCursor created_at_-1 reverse",
        "isMultiKey" : false,
        "n" : 10,
        "nscannedObjects" : 46462,
        "nscanned" : 46462,
        "nscannedObjectsAllPlans" : 49763,
        "nscannedAllPlans" : 49763,
        "scanAndOrder" : false,
        "indexOnly" : false,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "millis" : 205,
        "indexBounds" : {
                "created_at" : [
                        [
                                {
                                        "$minElement" : 1
                                },
                                {
                                        "$maxElement" : 1
                                }
                        ]
                ]
        },
        "server" : "localhost.localdomain:27017"
}
</pre><choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>This query performs a collection scan.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The query uses an index to determine the order in which to return result documents.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query uses an index to determine which documents match.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query returns 46462 documents.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The query visits 46462 documents.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query is a "covered index query".<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='HW 4.3' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_4_3_problem' rerandomize='never' display_name='Quiz: HW 4.3'>
<b>Making the Blog fast</b>
<p>Please download <a href="/static/handouts/hw4-3.tar">hw4-3.tar</a> (mac) or <a href="/static/handouts/hw4-3.zip">hw4-3.zip</a> (pc) to get started. This assignment requires Mongo 2.2 or above. </p>

<p>In this homework assignment you will be adding some indexes to the post collection to make the blog fast.</p>

<p>We have provided the full code for the blog application and you don't need to make any changes, or even run the blog. But you can, for fun.</p>

<p>We are also providing a patriotic (if you are an American) data set for the blog. There are 1000 entries with lots of comments and tags. You must load this dataset to complete the problem.</p>
<pre>
# from the mongo shell
use blog
db.posts.drop()
# from the a mac or PC terminal window
mongoimport -d blog -c posts &lt; posts.json
</pre>
<p>
The blog has been enhanced so that it can also display the top 10 most recent posts by tag. There are hyperlinks from the post tags to the page that displays the 10 most recent blog entries for that tag. (run the blog and it will be obvious)
</p><p>
Your assignment is to make the following blog pages fast:
</p>
<ul>
<li>The blog home page</li>
<li>The page that displays blog posts by tag (http://localhost:8082/tag/whatever)</li>
<li>The page that displays a blog entry by permalink (http://localhost:8082/post/permalink)</li>
</ul>
By fast, we mean that indexes should be in place to satisfy these queries such that we only need to scan the number of documents we are going to return.

<p>
To figure out what queries you need to optimize,  you can read the blog.py code and see what it does to display those pages. Isolate those queries and use explain to explore.
</p><p>
Once you have added the indexes to make those pages fast run the following.
</p>
<pre>
python validate.py
</pre>
(note that for folks who are using MongoLabs or MongoHQ there are some command line options to validate.py to make it possible to use those services)
Now enter the validation code below. 
<customresponse>
<textbox rows='4' cols='50' correct_answer="nffhe89hfkdjsbapajsfda89jks"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''nffhe89hfkdjsbapajsfda89jks'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='HW 4.4' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_4_4_problem' rerandomize='never' display_name='Quiz: HW 4.4'>
In this problem you will analyze a profile log taken from a mongoDB instance. To start, please download <a href="/static/handouts/sysprofile.json"> sysprofile.json</a> and import it with the following command:

<pre>
mongoimport -d m101 c profile &lt; sysprofile.json
</pre>

Now query the profile data, looking for all queries to the <i>students</i> collection in the database <i>school2</i>, sorted in order of decreasing latency. What is the latency of the longest running operation to the collection, in milliseconds?
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>4715</text></choice>
<choice location='bottom' correct='false'><text>34430</text></choice>
<choice location='bottom' correct='false'><text>5018</text></choice>
<choice location='bottom' correct='true'><text>15820</text></choice>
<choice location='bottom' correct='false'><text>3217</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
</chapter>
</course>
