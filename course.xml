<course url_name='2012_Fall' org='10gen' course='M101' display_name='MongoDB for Developers' start='2012-10-22T00:00' enrollment_start='2012-10-01T00:00' enrollment_end='2012-12-01T00:00'>
<chapter start='2012-10-22T00:00' display_name='Week 1 - Introduction'>
<sequential graded='false' display_name='Welcome to M101' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:179MiZSibco'/>
</vertical>
<problem showanswer='attempted' url_name='Welcome_to_M101_problem' rerandomize='never' display_name='Quiz: Welcome to M101'>
What counts toward your final grade in the class?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Quizzes<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Homeworks<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Final Exam<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Class Participation<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:xVfrAfEyfb0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='What is MongoDB?' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Lfl8hdQOi6Y'/>
</vertical>
<problem showanswer='attempted' url_name='What_is_MongoDB__problem' rerandomize='never' display_name='Quiz: What is MongoDB?'>
Which of the following statements are true about MongoDB?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>MongoDB is document oriented.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>MongoDB supports Joins.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>MongoDB is schemaless<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>MongoDB supports SQL.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:h80NwJJZM-g'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo Relative to Relational' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:-KIC1LXxcGM'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_Relative_to_Relational_problem' rerandomize='never' display_name='Quiz: Mongo Relative to Relational'>
Which features did MongoDB omit in order to retain scalability?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Joins<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Indexes<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Secondary Indexes<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Transactions across multiple collections<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:IAvnMgvHuLw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Overview of Building an app with Mongo' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:_e0J06elxb8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Quick Introduction to the Mongo Shell' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:f-lyGAMnNY4'/>
</vertical>
<problem showanswer='attempted' url_name='Quick_Introduction_to_the_Mongo_Shell_problem' rerandomize='never' display_name='Quiz: Quick Introduction to the Mongo Shell'>
Which of the following expressions are valid JSON documents?
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>{a:1, b:2, c:3}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{a,1; b,4, c,6}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{a:1; b:1; c:4}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>(A,1; b:2; c,4}<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:YQTqdLe3W4M'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON introduced' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:2jsJeH8q6YM'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_introduced_problem' rerandomize='never' display_name='Quiz: JSON introduced'>
Which of the following are valid JSON documents?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>{a:1, b:2, c: 3}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{a:1, b:2, c:[1,2,3,4,5]}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{a:1, b:{}, c: [ { a:1, b:2}, 5, 6]}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{  }<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:uWcOsdV4Iz4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing MongoDB (mac)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:6VFukRETCTg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing MongoDB (windows)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:hX5louVryOQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing Bottle and Python (mac)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:vxTN6KFegLg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing Python (windows)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:njfPdZTmTrI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing Bottle.py (windows)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:OhEpXjL0vt8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing PyMongo (mac)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:XRJawbpWxtg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Installing PyMongo (windows)' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:YwWc6HZ0LWo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hello World, Mongo Style' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:IG7PntLyv2E'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hello World on a Web Server' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:8_o6nyenZbk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo is Schemaless' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:K6dlBbH_XHI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Revisited' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:zbYCcMWJGNY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Arrays' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:JkK9n6_ahVk'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Arrays_problem' rerandomize='never' display_name='Quiz: JSON Arrays'>
Write the JSON for a simple document containing a single key "fruit" that has as its value an array containing three strings: "apple", "pear", and "peach"<customresponse>
<textbox rows='4' cols='50' correct_answer="{'fruit': ['apple', 'pear', 'peach']}"> </textbox>
<answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{'fruit': ['apple', 'pear', 'peach']}'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ciuq7XPqHKI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Subdocuments' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:vrYAEH3g13M'/>
</vertical>
<problem showanswer='attempted' url_name='JSON_Subdocuments_problem' rerandomize='never' display_name='Quiz: JSON Subdocuments'>
Write a JSON document with a single key, "address" that has as it value another document with the keys 
'street_address', 'city', 'state', 'zipcode', with the following values: 'street_address' is "23 Elm Drive", 'city' is "Palo Alto", 'state' is "California", 'zipcode' is "94305"<customresponse>
<textbox rows='4' cols='50' correct_answer="{'address': {'street_address': &quot;23 Elm Drive&quot;, 'city' : &quot;Palo Alto&quot;, 'state': &quot;California&quot;, 'zipcode': &quot;94305&quot;} }"> </textbox>
<answer type='loncapa/python'><![CDATA[
import demjson
correct = ['correct']
messages = ['']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
quiz_answer = '''{'address': {'street_address': "23 Elm Drive", 'city' : "Palo Alto", 'state': "California", 'zipcode': "94305"} }'''
quiz_answer_json = {}
try:
  quiz_answer_json = demjson.decode(quiz_answer)
except demjson.JSONDecodeError as err:
  messages[0] = 'Quiz Answer failed to parse' + str(err)
response_json = {}
try:
  response_json = demjson.decode(r)
except demjson.JSONDecodeError as err:
  messages[0] = 'Response failed to parse' + str(err)
if not(response_json == quiz_answer_json):
  correct[0] = 'incorrect'
]]></answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:NGp_y6BaEMw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='JSON Spec' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:kOrsT94-A28'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Introduction to our class project, the blog' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:ePi3kDoexoM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog in Relational Tables' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:boR2y9MHCa0'/>
</vertical>
<problem showanswer='attempted' url_name='Blog_in_Relational_Tables_problem' rerandomize='never' display_name='Quiz: Blog in Relational Tables'>
letâ€™s assume that our blog can be modeled with the following relational tables:

<pre>
authors:
	author_id,
	name,
	email,
	password

posts:
	post_id,
	author_id
	title,
	body,	
	publication_date

comments:
	comment_id,
	name, 
	email,
	comment_text

post_comments:
	post_id,
	comment_id


tags
	tag_id
	name

post_tags
	post_id
	tag_id
</pre>

In order to display a blog post with its comments and tags, how many tables will need to be accessed?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>3</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
<choice location='bottom' correct='true'><text>6</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vB-4AbbLKeg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog in Documents' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ZjwCzyqKVdY'/>
</vertical>
<problem showanswer='attempted' url_name='Blog_in_Documents_problem' rerandomize='never' display_name='Quiz: Blog in Documents'>
Given the document schema that we proposed for the blog, how many collections would we need to access to display the blog home page?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>0</text></choice>
<choice location='bottom' correct='true'><text>1</text></choice>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>4</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:WJblHPsp1p4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Intro to Schema Design' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:6XE3wZCPiZ8'/>
</vertical>
<problem showanswer='attempted' url_name='Intro_to_Schema_Design_problem' rerandomize='never' display_name='Quiz: Intro to Schema Design'>
In which scenario is it impossible to embed data within a document (you must put the data in it a separate collection). Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>The data would be duplicated across multiple objects within a collection.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>You need an index on the data element.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The embedded data could exceed the 16MB document limit within MongoDB<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The data is not isomorphic.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:wiwOEG_6ojs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Intro to Python' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:-cAtffa59FM'/>
</vertical>
<problem showanswer='attempted' url_name='Intro_to_Python_problem' rerandomize='never' display_name='Quiz: Intro to Python'>
Write an expression to concatenate two strings "hat" and "pin" in python to the string "hatpin"<customresponse>
<textbox rows='4' cols='50' correct_answer='"hat" + "pin"'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''"hat" + "pin"'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:PuyAdxxzSk0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:H1BOYfbnPq8'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_problem' rerandomize='never' display_name='Quiz: Python Lists'>
Write the to code to initialize a list with the items "hammer", "nail" and "wall" and assign the list to the variable named "things".<customresponse>
<textbox rows='4' cols='50' correct_answer='things = ["hammer", "nail", "wall"]'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things = ["hammer", "nail", "wall"]'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:8WdnrhlfSLE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists, Manipulating' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:PHii2QYNyB8'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_Manipulating_problem' rerandomize='never' display_name='Quiz: Python Lists, Manipulating'>
Write the code to append the item "hammer" onto a list named things.

<p>Please use double quotes at this time.</p><customresponse>
<textbox rows='4' cols='50' correct_answer='things.append("hammer")'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things.append("hammer")'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ZSraFzkEDzs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists, Slice Operator' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:vNyIZNWK0rw'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_Slice_Operator_problem' rerandomize='never' display_name='Quiz: Python Lists, Slice Operator'>
things = ['apples', 'orange', 'pear', 'grape', 'kiwi']. What is the slice notation that will return the sublist ['orange', 'pear']?
<customresponse>
<textbox rows='4' cols='50' correct_answer="things[1:3]"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things[1:3]'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vE498xAFoGc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python Lists, Inclusion' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:QXUMUvHB2Ws'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Lists_Inclusion_problem' rerandomize='never' display_name='Quiz: Python Lists, Inclusion'>
given a python list called "fruit", write an if statement to check whether "apple" is in the list.

<p>Please use double quotes at this time.</p><customresponse>
<textbox rows='4' cols='50' correct_answer='if "apple" in fruit:&#10;'> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''if "apple" in fruit:
'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:LdA0__D4zLI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python, Working with Dicts' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:_AbCyE0uKmE'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Working_with_Dicts_problem' rerandomize='never' display_name='Quiz: Python, Working with Dicts'>
Initialize a new dict named "colors" with the following key values pairs: sky is blue, sea is blue. earth is brown.

<i>Note:  Please preserve the order of these keys when you enter your answer.</i><customresponse>
<textbox rows='4' cols='50' correct_answer="colors = {'sky': 'blue', 'sea' : 'blue', 'earth': 'brown'}"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''colors = {'sky': 'blue', 'sea' : 'blue', 'earth': 'brown'}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:edEYrBoa7Ao'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: Dicts and Lists together' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:9k1XvuoGdrk'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Dicts_and_Lists_together_problem' rerandomize='never' display_name='Quiz: Python: Dicts and Lists together'>
Initialize a new dict with a single key, "animals" whose value is the list "dog", "cat", "zebra" and assign the entire expression to variable named "things"<customresponse>
<textbox rows='4' cols='50' correct_answer="things = {'animals' : ['dog', 'cat', 'zebra']}"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''things = {'animals' : ['dog', 'cat', 'zebra']}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Gqb-OUFcQas'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: for loops, with Lists' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:zMqLCtf3ML4'/>
</vertical>
<problem showanswer='attempted' url_name='Python_for_loops_with_Lists_problem' rerandomize='never' display_name='Quiz: Python: for loops, with Lists'>
What does the following code print?

<pre>
sum = 0
numbers = [1,2,3,5,8]
for i in numbers:
  sum = sum + i
print i
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer="8"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''8'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ohA78_D5Rn8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: for loops with dicts' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:HHTICY6rUGI'/>
</vertical>
<problem showanswer='attempted' url_name='Python_for_loops_with_dicts_problem' rerandomize='never' display_name='Quiz: Python: for loops with dicts'>
<pre>
people = {'name':'Bob', 'hometown': "Palo Alto", 'favorite_color': 'red'}
for item in people:
  if (item == 'favorite_color'):
     print  people[item]
</pre>

What does this program print?<customresponse>
<textbox rows='4' cols='50' correct_answer="red"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''red'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:OnkPdMP1fVc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: Combining Dicts and Lists' chapter_name='Week 1 - Introduction' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ome7jDN_lH0'/>
</vertical>
<problem showanswer='attempted' url_name='Python_Combining_Dicts_and_Lists_problem' rerandomize='never' display_name='Quiz: Python: Combining Dicts and Lists'>

<pre>
obj = {'a':1,'b': 2, 'c': [1, 3, 5]}

sum = 0
if 'c' in obj:
   for n in obj['c']:
     sum = sum + n

print sum
</pre>
     <customresponse>
<textbox rows='4' cols='50' correct_answer="9"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''9'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Y6NKd6xUC6M'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: while loops' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:TEdFAheS5UE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: function calls' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:PizwcirYuGY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Python: exception handling' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:nrZYqF9KwaU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: Url Handlers' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:x5TlvbWxjL0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: using views' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:GUFDtACjFcc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: handling form content' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:sUUT-gIS5ik'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bottle framework: using cookies' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:Wk_1Lz_-gk4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Pymongo driver' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:u2kRRt861bU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo driver, safe mode, exception processing' chapter_name='Week 1 - Introduction'>
<vertical>
<video display_name='Lecture' youtube='1.0:GR6W-gHffXw'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.1' chapter_name='Week 1 - Introduction' format='Homework' due='Oct 30 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:r48N7GcDqVI'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='Homework_1_1_problem' rerandomize='never' display_name='Homework: Homework 1.1'>
Install MongoDB on your computer and run it on the standard port.

<p>
Download the <a href="/static/handouts/hw1.tar">HW1 tarball (mac)</a> or <a href="/static/handouts/hw1.zip">zipfile (windows)</a>, expand it as follows:
</p>
Mac Users
<pre>
tar xvf hw1.tar
</pre>
Windows Users
<pre>
You probably don't have tar installed so right click on the hw1.zip file and choose "extract all"
</pre>
Use mongorestore to restore the dump into your running mongod. Do this by opening a terminal window (mac) or cmd window (windows) and navigating to the directory so that the dump directory is directly beneath you. Now type
<pre>
mongorestore dump
</pre>
Note you will need to have your path setup correctly to find mongorestore.
<p>
Now, using the Mongo shell, perform a findone on the collection called <em>hw1</em> in the database <em>m101</em>. That will return one document. Please provide the value corresponding to the "answer" key from the document returned.
</p><customresponse>
<textbox rows='4' cols='50' correct_answer="42"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''42'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:memPfvehjGo'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.2' chapter_name='Week 1 - Introduction' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_2_problem' rerandomize='never' display_name='Homework: Homework 1.2'>
Get Pymongo installed on your computer. To prove its installed, run the program:

<pre>
python hw1-2.py
</pre>

This program will print a numeric answer.  Please put just the number into the space below.  Note that you will need to get MongoDB installed and the homework dataset imported from the previous homework before attempting this problem.<customresponse>
<textbox rows='4' cols='50' correct_answer="1815"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''1815'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ZeF4fdLDoMY'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 1.3' chapter_name='Week 1 - Introduction' format='Homework' due='Oct 30 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_1_3_problem' rerandomize='never' display_name='Homework: Homework 1.3'>
We are now going to test that you have bottle installed correctly and can run a bottle-based project. Run the hw1-3.py download as follows:
<pre>
python hw1-3.py
</pre>
It requires bottle to be installed correctly, your mongodb to be running, and that you have run mongorestore properly.  From a different terminal window type the following from the command line: curl http://localhost:8080/hw1/50
<p>
Type the answer into the box below
</p><customresponse>
<textbox rows='4' cols='50' correct_answer="53"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''53'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cmSs92zp4aA'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-10-29T00:00' display_name='Week 2 - CRUD'>
<sequential graded='false' display_name='Introduction to Week 2' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:kB_9lXE-EbY'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_Week_2_problem' rerandomize='never' display_name='Quiz: Introduction to Week 2'>
By the end of this week, you'll know which of the following?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>MongoDB's basic document creation, retrieval, modification, and removal operations<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Some features of the MongoDB shell, mongo<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>How to measure performance of MongoDB operations<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>How to manipulate MongoDB documents from Python<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>How to analyze data in MongoDB collections<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:osal1NuP4UA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Secrets of the Mongo Shell' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:hJy10xgZXzc'/>
</vertical>
<problem showanswer='attempted' url_name='Secrets_of_the_Mongo_Shell_problem' rerandomize='never' display_name='Quiz: Secrets of the Mongo Shell'>
What does the following fragment of JavaScript output?

<pre>
x = { "a" : 1 };
y = "a";
x[y]++;
print(x.a);
</pre>
<customresponse>
<textbox rows='4' cols='50' correct_answer="2"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''2'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:a6TFwpCoLoY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='BSON Introduced' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:K3J6WvDW-Hc'/>
</vertical>
<problem showanswer='attempted' url_name='BSON_Introduced_problem' rerandomize='never' display_name='Quiz: BSON Introduced'>
Which of the following are types available in BSON?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Strings<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Floating-point numbers<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Complex numbers<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Arrays<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Objects<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Timestamps<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4hsTQrMs-xY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, inserting docs' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:RbRRvBLl7Qo'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_shell_inserting_docs_problem' rerandomize='never' display_name='Quiz: Mongo shell, inserting docs'>
Insert a document into the "fruit" collection with the attributes of "name" being "apple", "color" being "red", and "shape" being round. Assume that we have already issued the use command to get into the right database. Use the "insert" method.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.fruit.insert({name:"apple", color:"red", shape:"round"})'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.fruit.insert({name:"apple", color:"red", shape:"round"})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4eqpL7ETQZQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, introdution to findOne' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:w9V0fJsDwbQ'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_shell_introdution_to_findOne_problem' rerandomize='never' display_name='Quiz: Mongo shell, introdution to findOne'>
Use <em>findOne</em> on the collection <em>users</em> to find one document where the key <em>username</em> is "dwight", and retrieve only the key named <em>email</em>.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.users.findOne ( { "username" : "dwight" } , { "_id" : false , "email" : true } );'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.findOne ( { "username" : "dwight" } , { "_id" : false , "email" : true } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:uN_wf5a3BE4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, introduction to find' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:8kKfFK6a0Ak'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo shell, querying using field selection' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:UIg86QjSoyY'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_shell_querying_using_field_selection_problem' rerandomize='never' display_name='Quiz: Mongo shell, querying using field selection'>
Supposing a <em>scores</em> collection similar to the one presented, how would you find all documents with an essay score equal to 50 and only retrieve the <em>student</em> field?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.scores.find({ type:"essay", score:50}, {student:true,_id:false});'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find({ type:"essay", score:50}, {student:true,_id:false});'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ouHFZgtEAuU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Querying using $gt and $lt' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:FHLrz4VGzkg'/>
</vertical>
<problem showanswer='attempted' url_name='Querying_using_gt_and_lt_problem' rerandomize='never' display_name='Quiz: Querying using $gt and $lt'>
Which of these finds documents with a score between 50 and 60, inclusive?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 , $lt : 60 } } );</text></choice>
<choice location='bottom' correct='true'><text>db.scores.find({ score : { $gte : 50 , $lte : 60 } } );</text></choice>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 , $lte : 60 } } );</text></choice>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gte : 50 , $lt : 60 } } );</text></choice>
<choice location='bottom' correct='false'><text>db.scores.find({ score : { $gt : 50 } } );</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:tY7I1l8JdDI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Inequalities on strings' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:imCCKOevU3c'/>
</vertical>
<problem showanswer='attempted' url_name='Inequalities_on_strings_problem' rerandomize='never' display_name='Quiz: Inequalities on strings'>
Which of the following will find all users with <em>name</em> between "F" and "Q"?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>db.users.find( { name : { $gte : "F" ,  $lte : "Q" } } );<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.users.find( { name : { $lte : "Q" , $gte : "F" } } );<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.users.find( { name : { $gte : "f" ,  $lte : "Q" } } );<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.users.find( { name :  { $lte : "Q" } });<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ZRWT0lcHsoU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using regexes, $exists, $type' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:lI-jhqYf1JY'/>
</vertical>
<problem showanswer='attempted' url_name='Using_regexes_exists_type_problem' rerandomize='never' display_name='Quiz: Using regexes, $exists, $type'>
Write a query that retrieves documents from a <em>users</em> collection where the <em>name</em> has a "q" in it, and the document has an <em>email</em> field.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.users.find({ name : { $regex : "q" }, email : { $exists: true } } );'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.find({ name : { $regex : "q" }, email : { $exists: true } } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:yMi7PwOoqXY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $or' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:BW5ElNCRZps'/>
</vertical>
<problem showanswer='attempted' url_name='Using_or_problem' rerandomize='never' display_name='Quiz: Using $or'>
How would you find all documents in the <em>scores</em> collection where the <em>score</em> is less than 50 or greater than 90?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.scores.find( { $or : [ { score : { $lt : 50 } }, { score : { $gt : 90 } } ] } ) ;"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find( { $or : [ { score : { $lt : 50 } }, { score : { $gt : 90 } } ] } ) ;'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:diimYkvr374'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $and' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:hYk7pjgjjzc'/>
</vertical>
<problem showanswer='attempted' url_name='Using_and_problem' rerandomize='never' display_name='Quiz: Using $and'>
What will the following query do?

<pre>db.scores.find( { score : { $gt : 50 }, score : { $lt : 60 } } );</pre><choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Find all documents with score between 50 and 60<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Find all documents with score greater than 50<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Find all documents with score less than 60<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Explode like the Death Star<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>None of the above<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:oIkSajy8NLw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Querying inside arrays' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:jvEqwW75Bus'/>
</vertical>
<problem showanswer='attempted' url_name='Querying_inside_arrays_problem' rerandomize='never' display_name='Quiz: Querying inside arrays'>
Which of the following documents would be returned by this query?

<pre>db.products.find( { tags : "shiny" } );</pre><choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>{ _id : 42 , name : "Whizzy Wiz-o-matic", tags : [ "awesome", "shiny" , "green" ] }<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{ _id : 704 , name : "Fooey Foo-o-tron", tags : [ "blue", "mediocre" ] }<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{ _id : 1040 , name : "Snappy Snap-o-lux", tags : "shiny" }<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{ _id : 12345 , name : "Quuxinator", tags : [ ] }<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:gwECaa4N9Xc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $in and $all' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Lv-tYcQfuZg'/>
</vertical>
<problem showanswer='attempted' url_name='Using_in_and_all_problem' rerandomize='never' display_name='Quiz: Using $in and $all'>
Which of the following documents matches this query?

<pre>db.users.find( { friends : { $all : [ "Joe" , "Bob" ] }, favorites : { $in : [ "running" , "pickles" ] } } )</pre><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>{ name : "William" , friends : [ "Bob" , "Fred" ] , favorites : [ "hamburgers", "running" ] }</text></choice>
<choice location='bottom' correct='false'><text>{ name : "Stephen" , friends : [ "Joe" , "Pete" ] , favorites : [ "pickles", "swimming" ] }</text></choice>
<choice location='bottom' correct='true'><text>{ name : "Cliff" , friends : [ "Pete" , "Joe" , "Tom" , "Bob" ] , favorites : [ "pickles", "cycling" ] }</text></choice>
<choice location='bottom' correct='false'><text>{ name : "Harry" , friends : [ "Joe" , "Bob" ] , favorites : [ "hot dogs", "swimming" ] }</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:O8YQRq4vXig'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Queries with dot notation' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:NrjFECIfwqk'/>
</vertical>
<problem showanswer='attempted' url_name='Queries_with_dot_notation_problem' rerandomize='never' display_name='Quiz: Queries with dot notation'>
Suppose a simple e-commerce product catalog called <em>catalog</em> with documents that look like this:

<pre>
{ product : "Super Duper-o-phonic", 
  price : 100000000000,
  reviews : [ { user : "fred", comment : "Great!" , rating : 5 },
              { user : "tom" , comment : "I agree with Fred, somewhat!" , rating : 4 } ],
  ... }
</pre>

Write a query that finds all products that cost more than 10,000 and that have a rating of 5 or better.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.catalog.find( { price : { $gt : 10000 } , "reviews.rating" : { $gte : 5 } } ); '> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.catalog.find( { price : { $gt : 10000 } , "reviews.rating" : { $gte : 5 } } ); '''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:yiEjK_V008s'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Querying, cursors' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:3jA6iFSEJOI'/>
</vertical>
<problem showanswer='attempted' url_name='Querying_cursors_problem' rerandomize='never' display_name='Quiz: Querying, cursors'>
Recall the documents in the scores collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

Write a query that retrieves exam documents, sorted by score in descending order, skipping the first 50 and showing only the next 20.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.scores.find( { type : "exam" } ).sort( { score : -1 } ).skip(50).limit(20)'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.find( { type : "exam" } ).sort( { score : -1 } ).skip(50).limit(20)'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:djzpK7UIO94'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Counting results' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:eKD5bVmNQMI'/>
</vertical>
<problem showanswer='attempted' url_name='Counting_results_problem' rerandomize='never' display_name='Quiz: Counting results'>
How would you count the documents in the <em>scores</em> collection where the type was "essay" and the score was greater than 90?<customresponse>
<textbox rows='4' cols='50' correct_answer='db.scores.count({ type:"essay", score:{$gt:90}});'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.count({ type:"essay", score:{$gt:90}});'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Uozp0diXOc8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Wholesale Updating of a Document' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:EBCk6W7x-OY'/>
</vertical>
<problem showanswer='attempted' url_name='Wholesale_Updating_of_a_Document_problem' rerandomize='never' display_name='Quiz: Wholesale Updating of a Document'>
Let's say you had a collection with the following document in it:
<pre>
{ "_id" : "Texas", "population" : 2500000, "land_locked" : 1 }
</pre>
and you issued the query:
<pre>
db.foo.update({_id:"Texas"},{population:30000000})
</pre>
What would be the state of the collection after the update?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>{ "_id" : "Texas", "population" : 2500000, "land_locked" : 1 }
</text></choice>
<choice location='bottom' correct='false'><text>{ "_id" : "Texas", "population" : 3000000, "land_locked" : 1 }
</text></choice>
<choice location='bottom' correct='true'><text>{ "_id" : "Texas", "population" : 30000000 }</text></choice>
<choice location='bottom' correct='false'><text>{ "_id" : ObjectId("507b7c601eb13126c9e3dcca"), "population" : 2500000 }</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pwnRUdtI8lY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using the $set command' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:9iMX2KxYAd8'/>
</vertical>
<problem showanswer='attempted' url_name='Using_the_set_command_problem' rerandomize='never' display_name='Quiz: Using the $set command'>
Given the document
<pre>
{'username':'splunker', 'country':'US', 'phone':'718-343-3433'}
</pre>
in the collection <em>users</em>, write the shell command for updating the country to 'RU' for only this user. <customresponse>
<textbox rows='4' cols='50' correct_answer="db.users.update({'username':'splunker'},{$set:{'country':'RU'}})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({'username':'splunker'},{$set:{'country':'RU'}})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:F6ZY_VVAXZ8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using the $unset command' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Kxd4MXBEx-I'/>
</vertical>
<problem showanswer='attempted' url_name='Using_the_unset_command_problem' rerandomize='never' display_name='Quiz: Using the $unset command'>
Write an update query that will unset the <em>interests</em> key in the following document in the collection <em>users</em>.  The primary key is <em>username</em>.
<pre>
{'username':'jimmy', favorite_color:'blue', interests:['debating', 'politics']}
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer="db.users.update({username:'jimmy'}, {$unset:{'interests':1}})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.users.update({username:'jimmy'}, {$unset:{'interests':1}})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:edqDAKMQTv4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $push, $pop, $pull, $pushAll, $pullAll, $addToSet' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:iHSwyr7bfQs'/>
</vertical>
<problem showanswer='attempted' url_name='Using_push_pop_pull_pushAll_pullAll_addToSet_problem' rerandomize='never' display_name='Quiz: Using $push, $pop, $pull, $pushAll, $pullAll, $addToSet'>
Suppose you have the following document in your <em>friends</em> collection:

<pre>
{ _id : "Mike", interests : [ "chess", "botany" ] }
</pre>

What will the result of the following updates be?

<pre>
db.friends.update( { _id : "Mike" }, { $push : { interests : "skydiving" } } );
db.friends.update( { _id : "Mike" }, { $pop : { interests : -1 } } );
db.friends.update( { _id : "Mike" }, { $addToSet : { interests : "skydiving" } } );
db.friends.update( { _id : "Mike" }, { $pushAll: { interests : [ "skydiving" , "skiing" ] } } );
</pre><customresponse>
<textbox rows='4' cols='50' correct_answer='{ _id : "Mike" , "interests" : [ "botany", "skydiving", "skydiving", "skiing" ] }'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''{ _id : "Mike" , "interests" : [ "botany", "skydiving", "skydiving", "skiing" ] }'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:bGbiIGEM0FY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Upserts' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:dfvwrlVODGc'/>
</vertical>
<problem showanswer='attempted' url_name='Upserts_problem' rerandomize='never' display_name='Quiz: Upserts'>
After performing the following update on an empty collection
<pre>
db.foo.update({username:'bar'}, {'$set':{'interests':['cat', 'dog']}}, {upsert: true} );
</pre>
What could be the state of the collection.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>{ "_id" : ObjectId("507b78232e8dfde94c149949"), "interests" : [ "cat", "dog" ]}<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{"interests" : [ "cat", "dog" ], "username" : "bar" }<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>{}<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>{ "_id" : ObjectId("507b78232e8dfde94c149949"), "interests" : [ "cat", "dog" ], "username" : "bar" }<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Loo5XKQAryM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multi-update' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:8uNNDduO09w'/>
</vertical>
<problem showanswer='attempted' url_name='Multi_update_problem' rerandomize='never' display_name='Quiz: Multi-update'>
Recall the schema of the <em>scores</em> collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

How would you give every record whose score was less than 70 an extra 20 points?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.scores.update( { score : { $lt: 70 } } , { $inc : { score : 20 } } , { multi : true } );"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.update( { score : { $lt: 70 } } , { $inc : { score : 20 } } , { multi : true } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:B1DqIls06Tc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Removing data' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:PMhGgc3HCn4'/>
</vertical>
<problem showanswer='attempted' url_name='Removing_data_problem' rerandomize='never' display_name='Quiz: Removing data'>
Recall the schema of the <em>scores</em> collection:

<pre>
{
	"_id" : ObjectId("50844162cb4cf4564b4694f8"),
	"student" : 0,
	"type" : "exam",
	"score" : 75
}
</pre>

How would you delete every record whose score was less than 60?<customresponse>
<textbox rows='4' cols='50' correct_answer="db.scores.remove( { score : { $lt : 60 } } );"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.scores.remove( { score : { $lt : 60 } } );'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:T3wcuZHm6Ac'/>
</vertical>
</sequential>
<sequential graded='false' display_name='getLastError' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:kUulkJQvH_A'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, find, find_one and cursors' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:kXu5V3MlFI0'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_find_find_one_and_cursors_problem' rerandomize='never' display_name='Quiz: Pymongo, find, find_one and cursors'>
In the following code snippet:
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the school database
db=connection.school
scores = db.scores
     
try:
        xxxx
        
except:
        print "Unexpected error:", sys.exc_info()[0]


print doc
</pre>
please enter the one line of python code that would be needed in in place of xxxx to find one document in the collection.<customresponse>
<textbox rows='4' cols='50' correct_answer="doc = scores.find_one()"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''doc = scores.find_one()'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:d-EOPb3_YVI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using field selection' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pCRMWfF_SC8'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_using_field_selection_problem' rerandomize='never' display_name='Quiz: Pymongo, using field selection'>
Which of the following could work using pymongo, depending on variable names, to select out just the student_id from the scores collection using a find command.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>cursor = students.find({'student_id':1, '_id':0})</text></choice>
<choice location='bottom' correct='false'><text>cursor = students.find({'student_id':1})</text></choice>
<choice location='bottom' correct='true'><text>cursor = students.find({}, {'student_id':1, '_id':0})</text></choice>
<choice location='bottom' correct='false'><text>cursor = students.find({}, {student_id:1, _id:0})</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vMNLxyQ47BM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using $gt and $lt' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:p5ltB0g3lUo'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_using_gt_and_lt_problem' rerandomize='never' display_name='Quiz: Pymongo, using $gt and $lt'>
In the following code, what is the correct line of code, marked by xxxx,  to search for all quiz scores that are greater than 20 and less than 90.
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the school database
db=connection.school
scores = db.scores


def find():

    print "find, reporting for duty"

    xxxx

    try:
        iter = scores.find(query)

    except:
        print "Unexpected error:", sys.exc_info()[0]
        
    return iter

find()
</pre>

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text> query = {'score':{'$gt':20, '$lt':90}}</text></choice>
<choice location='bottom' correct='true'><text> query = {'type':'quiz', 'score':{'$gt':20, '$lt':90}}</text></choice>
<choice location='bottom' correct='false'><text> query = {'type':'quiz', '$gt':{'score':20}, '$lt':{'score':90}}</text></choice>
<choice location='bottom' correct='false'><text> query = {'type':'quiz', 'score':{$gt:20, $lt:90}}</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:2kzdSZmJ8jM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Importing from Reddit' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:dd49ULz7y6Q'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using a regex' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:UIes2_2rBWE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, using dot notation' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:kiJRqBbCSGk'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_using_dot_notation_problem' rerandomize='never' display_name='Quiz: Pymongo, using dot notation'>
In the following code, what do you think will happen if a document that matches the query doesn't have a key called <i>media.oembed.url</i>?
<pre>

import pymongo
import sys

# establish a connection to the database
connection = pymongo.Connection("mongodb://localhost", safe=True)

# get a handle to the reddit database
db=connection.reddit
scores = db.stories


def find():

    print "find, reporting for duty"

    query = {'media.oembed.type':'video'}
    projection = {'media.oembed.url':1, '_id':0}

    try:
        iter = scores.find(query, projection)

    except:
        print "Unexpected error:", sys.exc_info()[0]

    sanity = 0
    for doc in iter:
        print doc
        sanity += 1
        if (sanity > 10):
            break
        

find()

</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Pymongo will throw an exception.</text></choice>
<choice location='bottom' correct='true'><text>Pymongo will return an empty document</text></choice>
<choice location='bottom' correct='false'><text>Pymongo will return a document with the following structure {media:{oembed:{url:{}}}}</text></choice>
<choice location='bottom' correct='false'><text>There is not enough information to know</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:5mpm64vncL0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, sort, skip and limit' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:F1bSsbt5Qfk'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_sort_skip_and_limit_problem' rerandomize='never' display_name='Quiz: Pymongo, sort, skip and limit'>
Supposed you had the following documents in a collection named things.
<pre>
{ "_id" : 0, "value" : 10 }
{ "_id" : 2, "value" : 5 }
{ "_id" : 3, "value" : 7 }
{ "_id" : 4, "value" : 20 }
</pre>
If you performed the following query in pymongo:
<pre>
cursor = things.find().skip(3).limit(1).sort('value",pymongo.DESCENDING)
</pre>
which document would be returned?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>The document with _id=0</text></choice>
<choice location='bottom' correct='true'><text>The document with _id=2</text></choice>
<choice location='bottom' correct='false'><text>The document with _id=3</text></choice>
<choice location='bottom' correct='false'><text>The doucment with _id=4</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cUNoJN6Ii-I'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, Sort, final thoughts' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:hwUg8r7a-d8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, Inserting' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:1buD4Ern9rA'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_Inserting_problem' rerandomize='never' display_name='Quiz: Pymongo, Inserting'>
Do you expect the second insert below to succeed?
<pre>

# get a handle to the school database
db=connection.school
people = db.people

doc = {"name":"Andrew Erlichson", "company":"10gen",
              "interests":['running', 'cycling', 'photography']}

try:
        people.insert(doc)   # first insert
        del(doc['_id'])
        people.insert(doc)   # second insert

except:
        print "Unexpected error:", sys.exc_info()[0]

</pre><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>No, because the _id will be a duplicate in the collection</text></choice>
<choice location='bottom' correct='false'><text>No, because the del call will delete the entire record in python</text></choice>
<choice location='bottom' correct='true'><text>Yes, because the del call will remove the _id key added by the pymongo driver in the first insert</text></choice>
<choice location='bottom' correct='false'><text>Yes, because the pymongo driver always adds a unique _id field on insert.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pEMyrKDzgFg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, Updating' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:u6iRURy8rY0'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_Updating_problem' rerandomize='never' display_name='Quiz: Pymongo, Updating'>
In the following code fragment, what is the python expression in place of xxxx to set a new key "examiner" to be "Jones"

Please use the $set operator

<pre>

def using_set():

    print "updating record using set"
    # get a handle to the school database
    db=connection.school
    scores = db.scores


    try:
        # get the doc
        score = scores.find_one({'student_id':1, 'type':'homework'})
        print "before: ", score

        # update using set
        scores.update({'student_id':1, 'type':'homework'},
                      xxxx)

        score = scores.find_one({'student_id':1, 'type':'homework'})
        print "after: ", score

    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise

</pre>
<customresponse>
<textbox rows='4' cols='50' correct_answer="{'$set':{'examiner':'Jones'}}"> </textbox>

<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'[\s\'";]+', '', r)
quiz_answer = '''{'$set':{'examiner':'Jones'}}'''

quiz_answer = re.sub(r'[\s\'";]+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Cyk5uzO-65w'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, upserts' chapter_name='Week 2 - CRUD' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:hcGo9lV9HwI'/>
</vertical>
<problem showanswer='attempted' url_name='Pymongo_upserts_problem' rerandomize='never' display_name='Quiz: Pymongo, upserts'>
Suppose we would like to upsert the following document into the collection <i>stuff</i>:
<pre>
{_id:"bat", friend:'ball', cousin:'glove'}
</pre>
Which of the following python statements work. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>stuff.update({'_id':'bat'},  {'friend':'ball', 'cousin':'glove'}, upsert=True)<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>stuff.update({'_id':'bat'},  {'friend':'ball', 'cousin':'glove'}, upsert=False)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>stuff.update({'_id':'bat'},  {'_id':'bat', 'friend':'ball', 'cousin':'glove'}, upsert=True)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>stuff.update({'_id':'bat'},  {'$set': {'friend':'ball', 'cousin':'glove'}}, upsert=True)<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:tMEohyZX0cI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Pymongo, find_and_modify' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:rQ8Oml5e6PI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog, User Interface' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:QA80WBg0hLg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog, Session Management' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:sNigml3JoY0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Blog, Internals' chapter_name='Week 2 - CRUD'>
<vertical>
<video display_name='Lecture' youtube='1.0:tTqQZvBGhyU'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.1' chapter_name='Week 2 - CRUD' format='Homework' due='Nov 9 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_1_problem' rerandomize='never' display_name='Homework: Homework 2.1'>
In this problem, you will be using a collection of student scores that is similar to what we used in the lessons. Please download the <a href="/static/handouts/grades.js">grades.js</a> file and import it into your local mongo database as follows:
<pre>
mongoimport -d students -c grades &lt; grades.js
</pre>
The dataset contains 4 scores for 200 students.
<p>
First, letâ€™s confirm your data is intact; the number of documents should be 800.
</p>
<pre>
> use students
> db.grades.count()
800
</pre>
<p>
This next query, which uses the aggregation framework that we have not taught yet, will tell you the <em>student_id</em> with the highest average score:
</p>

<pre>
> db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>
<b><i>Note:  Aggregation requires <a href="http://www.mongodb.org/downloads">mongodb 2.2</a> or above.</i></b>

<p>
The answer, deep in the resulting document, should be <em>student_id</em> 164 with an average of approximately 89.3.
</p>

Now itâ€™s your turn to analyze the data set. Find all exam scores greater than or equal to 65. and sort those scores from lowest to highest.
<p>What is the <em>student_id</em> of the lowest exam score above 65?</p>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>115</text></choice>
<choice location='bottom' correct='true'><text>22</text></choice>
<choice location='bottom' correct='false'><text>48</text></choice>
<choice location='bottom' correct='false'><text>57</text></choice>
<choice location='bottom' correct='false'><text>87</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:RUy50I3mrnU'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.2' chapter_name='Week 2 - CRUD' format='Homework' due='Nov 9 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_2_problem' rerandomize='never' display_name='Homework: Homework 2.2'>
<p>
Write a program in the language of your choice that will remove the grade of type "homework" with the lowest score for each student from the <a href="/static/handouts/grades.js">dataset</a> that you imported in HW 2.1.  Since each document is one grade, it should remove one document per student.
</p>
<p>
<i>Hint/spoiler</i>: If you select homework grade-documents, sort  by student and then by score, you can iterate through and find the lowest score for each student by noticing a change in student id. As you notice that change of student_id, remove the document.
</p>

<p>
To confirm you are on the right track, here are some queries to run after you process the data with the correct answer shown:
</p>

Let us count the number of grades we have:
<pre>
> db.grades.count() 
600
</pre>

Now let us find the student who holds the 101st best grade across all grades:
<pre>
> db.grades.find().sort({'score':-1}).skip(100).limit(1)
{ "_id" : ObjectId("50906d7fa3c412bb040eb709"), "student_id" : 100, "type" : "homework", "score" : 88.50425479139126 }
</pre>

Now let us sort the students by student_id, score and see what the top five docs are:
<pre>
> db.grades.find({},{'student_id':1, 'type':1, 'score':1, '_id':0}).sort({'student_id':1, 'score':1, }).limit(5)
{ "student_id" : 0, "type" : "quiz", "score" : 31.95004496742112 }
{ "student_id" : 0, "type" : "exam", "score" : 54.6535436362647 }
{ "student_id" : 0, "type" : "homework", "score" : 63.98402553675503 }
{ "student_id" : 1, "type" : "homework", "score" : 44.31667452616328 }
{ "student_id" : 1, "type" : "exam", "score" : 74.20010837299897 }
</pre>

<p>
To verify that you have completed this task correctly, provide the identify of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document. 
</p>
<pre>
> db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>

Enter the student ID below. Please enter just the number, with no spaces, commas or other characters.<customresponse>
<textbox rows='4' cols='50' correct_answer="54"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''54'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:xS0njlIkClY'/>
</vertical>
</sequential>
<sequential graded='true' display_name='Homework 2.3' chapter_name='Week 2 - CRUD' format='Homework' due='Nov 9 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='Homework_2_3_problem' rerandomize='never' display_name='Homework: Homework 2.3'>
<em>Blog User Sign-up and Login</em>
<p>
Download <a href="/static/handouts/hw2.3.zip">hw2.3.zip</a> or <a href="/static/handouts/hw2.3.tar">hw2.3.tar</a> and unpack.
</p>
<p>
You should see two files at the highest level: <i>blog.py</i> and <i>user.py</i>. There is also a views directory which contains the templates for the project. 
</p>
<p>
The project roughly follows the model/view/controller paradigm. <i>user.py</i> is the model. <i>blog.py</i> is the controller.  The templates comprise the view.
</p>

<p>
If everything is working properly, you should be able to start the blog by typing:
</p>
<pre>
python blog.py
</pre>

<p>
Note that this project requires the following python modules be installed on your computer: cgi, hmac, re, datetime, random, json, sys, string, hashlib, bson, urllib, urllib2, random, re, pymongo, and bottle. A typical Python installation will already have most of these installed except <i>pymongo</i> and <i>bottle</i>.
</p>
<p>
If you have python-setuptools installed, the command "easy_install" makes this simple.  Any other missing packages will show up when <i>validate.py</i> is run, and can be installed in a similar fashion.
</p>
<pre>
$ easy_install pymongo bottle
</pre>
<p>
If you goto <a href="http://localhost:8082/">http://localhost:8082</a> you should see a message â€œthis is a placeholder for the blogâ€
</p>

<p>
Here are some URLs that must work when you are done.
</p>
<pre>
http://localhost:8082/signup
http://localhost:8082/login
http://localhost:8082/logout
</pre>

<p>
When you login or sign-up, the blog will redirect to 
http://localhost:8082/welcome
and that must work properly, welcoming the user by username
</p>
<p>
We have removed two pymongo statements from user.py and marked the area where you need to work with XXX. You should not need to touch any other code.  The pymongo statements that you are going to add will add a new user upon sign-up and validate a login by retrieving the right user document. 
</p>
<p>
The blog stores its data in the blog database in two collections, <i>users</i> and <i>sessions</i>.  Here are two example docs for a username â€˜erlichsonâ€™ with password â€˜fubarâ€™. You can insert these if you like, but you donâ€™t need to.
</p>
<pre>
> db.users.find()
{ "_id" : "erlichson", "password" : "d3caddd3699ef6f990d4d53337ed645a3804fac56207d1b0fa44544db1d6c5de,YCRvW" }
> 
> db.sessions.find()
{ "_id" : ObjectId("50907cda49037223b802117d"), "username" : "erlichson" }
> 
</pre>

<p>
Once you have the the project working, the following steps should work:
</p>
<ul>
<li>go to http://localhost:8082/signup</li>
<li>create a user</li>
</ul>
It should redirect you to the welcome page and say: welcome username, where username is the user you signed up with.  Now
<ul>
<li>Goto http://localhost:8082/logout</li>
<li>Now login http://localhost:8082/login.</li>
</ul>
<br/>
<p>
Ok, now itâ€™s time to validate you got it all working.
</p>
<p>
There was one additional program that should have been downloaded in the project called <i>validate.py</i>.
</p>
<pre>
python validate.py
</pre>
If you got it right, it will provide a validation code for you to enter into the box below. Enter just the code, no spaces.
<customresponse>
<textbox rows='4' cols='50' correct_answer="h726dgdf63289wjaklf9467ghdsjkf"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''h726dgdf63289wjaklf9467ghdsjkf'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:94YWxpX3w-c'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-11-09T00:00' display_name='Week 3 - Schema Design'>
<sequential graded='false' display_name='Introduction to Week 3' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:itnfWjMnQ4A'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_Week_3_problem' rerandomize='never' display_name='Quiz: Introduction to Week 3'>
What's the single most important factor in designing your application schema within MongoDB?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Making the design extensible.</text></choice>
<choice location='bottom' correct='false'><text>Making it easy to read by a human.</text></choice>
<choice location='bottom' correct='true'><text>Matching the data access patterns of your application.</text></choice>
<choice location='bottom' correct='false'><text>Keeping the data in third normal form.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:OVDnLJXpqNE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Relational Normalization' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:GX__f2s4hd8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongo Design for Blog' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:PRylEHH5t84'/>
</vertical>
<problem showanswer='attempted' url_name='Mongo_Design_for_Blog_problem' rerandomize='never' display_name='Quiz: Mongo Design for Blog'>
Which data access pattern is not well supported by the blog schema?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Collecting the most recent blog entries for the blog home page</text></choice>
<choice location='bottom' correct='false'><text>Collecting all the information to display a single post</text></choice>
<choice location='bottom' correct='false'><text>Collecting all comments by a single author</text></choice>
<choice location='bottom' correct='true'><text>Providing a table of contents by tag</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:s5E0T4caqj4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Alternative Schema for Blog' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:ZvqNWVWB2-o'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Living Without Constraints' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:YFRMkDPaams'/>
</vertical>
<problem showanswer='attempted' url_name='Living_Without_Constraints_problem' rerandomize='never' display_name='Quiz: Living Without Constraints'>
What does Living Without Constraints refer to?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Living every day like it's your last</text></choice>
<choice location='bottom' correct='false'><text>Saying whatever you want when you want it</text></choice>
<choice location='bottom' correct='true'><text>Keeping your data consistent even though MongoDB lacks foreign key constraints</text></choice>
<choice location='bottom' correct='false'><text>Wearing no belt</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:3VckBMGInic'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Living without Transactions' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:FfRr3qjRfww'/>
</vertical>
<problem showanswer='attempted' url_name='Living_without_Transactions_problem' rerandomize='never' display_name='Quiz: Living without Transactions'>
Which of the following operations operate atomically within a single document? Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Update<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>findAndModify<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>$addToSet (within an update)<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>$push within an update<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:189zABW3HHk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='One to One Relations' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:cCsfon0vUlQ'/>
</vertical>
<problem showanswer='attempted' url_name='One_to_One_Relations_problem' rerandomize='never' display_name='Quiz: One to One Relations'>
What's a good reason you might want to keep two documents that are related to each other one-to-one in separate collections? Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Because you want to allow atomic update of both documents at once.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>To reduce the working set size of your application.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>To enforce foreign key constraints<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Because the combined size of the documents would be larger than 16MB<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:BjW64RkzlGg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='One To Many Relations' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:EIaP1KbVkUc'/>
</vertical>
<problem showanswer='attempted' url_name='One_To_Many_Relations_problem' rerandomize='never' display_name='Quiz: One To Many Relations'>
When is it recommended to represent a one to many relationship in multiple collections?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Always</text></choice>
<choice location='bottom' correct='true'><text>Whenever the many is large</text></choice>
<choice location='bottom' correct='false'><text>Whenever the many is actually few</text></choice>
<choice location='bottom' correct='false'><text>Never</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:KQcspnr-Y2M'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Many to Many Relations' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:fEYYjZ7zEHc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multikeys' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:ocU9WNUL9YQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Benefits of Embedding' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:XIN0Dqht08Q'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Trees' chapter_name='Week 3 - Schema Design' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:lIjXyQklGWY'/>
</vertical>
<problem showanswer='attempted' url_name='Trees_problem' rerandomize='never' display_name='Quiz: Trees'>
Given the following typical document for a e-commerce category hierarchy collection called <em>categories</em>
<pre>
{
  _id: 34,
  name : "Snorkeling",
  parent_id: 12,
  ancestors: [12, 35, 90]
}
</pre>
Which query will find all descendants of  the snorkeling category?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>db.categories.find({ancestors:{'$in':[12,35,90]}})</text></choice>
<choice location='bottom' correct='false'><text>db.categories.find({parent_id: 34})</text></choice>
<choice location='bottom' correct='false'><text>db.categories.find({_id:{'$in':[12,35,90]}})</text></choice>
<choice location='bottom' correct='true'><text>db.categories.find({ancestors:34})</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:80P6yVSkKQY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='When to Denormalize' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:jDZ-HFoJ0vg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Handling Blobs' chapter_name='Week 3 - Schema Design'>
<vertical>
<video display_name='Lecture' youtube='1.0:AsL5p1Z0Ss8'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 3.1' chapter_name='Week 3 - Schema Design' format='Homework' due='Nov 19 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:lpSMbphEl7c'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_3_1_problem' rerandomize='never' display_name='Homework: HW 3.1'>
Download the <a href="/static/handouts/students.js">students.js</a> file to your computer and import it into your local Mongo instance with this command:
<pre>
$ mongoimport -d school -c students &lt; students.js
</pre>
<p>
This dataset holds the same type of data as last week's grade collection, but it's modeled differently. You might want to start by inspecting it in the Mongo shell.
</p><p>
Write a program in the language of your choice that will remove the lowest homework score for each student. Since there is a single document for each student containing an array of scores, you will need to update the scores array and remove the homework.
</p><p>
Hint/spoiler: With the new schema, this problem is a lot harder and that is sort of the point. One way is to find the lowest homework in code and then update the scores array with the low homework pruned. If you are struggling with the Python side of this, look at the remove operator, which can remove stuff from a Python list.
</p><p>
To confirm you are on the right track, here are some queries to run after you process the data with the correct answer shown:
</p><p>

Let us count the number of students we have:
</p>
<pre>
> use school
> db.students.count() 
200
</pre>

Let's see what Demarcus Audette's record looks like:
<pre>
&gt; db.students.find({_id:100}).pretty()
{
	"_id" : 100,
	"name" : "Demarcus Audette",
	"scores" : [
		{
			"score" : 47.42608580155614,
			"type" : "exam"
		},
		{
			"score" : 44.83416623719906,
			"type" : "quiz"
		},
		{
			"score" : 39.01726616178844,
			"type" : "homework"
		}
	]
}

</pre>
<p>
To verify that you have completed this task correctly, provide the identify of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document.
</p>
<pre>
&gt; db.students.aggregate({'$unwind':'$scores'},{'$group':{'_id':'$_id', 'average':{$avg:'$scores.score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
</pre>

<customresponse>
<textbox rows='4' cols='50' correct_answer="13"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''13'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:iODR0m6m25c'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 3.2' chapter_name='Week 3 - Schema Design' format='Homework' due='Nov 19 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:SEh6Y4lHkWQ'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_3_2_problem' rerandomize='never' display_name='Homework: HW 3.2'>
<b>Making your blog accept posts</b>
<p>In this homework you will be enhancing the blog project to insert entries into the posts collection. After this, the blog will work. It will allow you to add blog posts with a title, body and tags and have it be added to the posts collection properly.
</p><p>We have provided the code that creates users and allows you to login (the assignment from last week). To get started, please download <a href="/static/handouts/hw3-blog.tar">hw3-blog.tar</a> or <a href="/static/handouts/hw3-blog.zip">hw3-blog.zip</a> and unpack. You will be using these file for this homework and the HW 3.3.
</p><p>
The areas where you need to add code are marked with XXX.  You need only touch the blog.py file.  There are three locations for you to add code for this problem. Scan that file for XXX to see where to work.
</p>
As a reminder, to run your blog you type<br/>
<pre>
python blog.py
</pre>
To play with the blog you can navigate to the following URLs<br/>
<pre>
http://localhost:8082/
http://localhost:8082/signup
http://localhost:8082/login
http://localhost:8082/newpost
</pre>
You will be proving that it works by running our validation script as follows:
<br/>
<pre>
python validate.py
</pre>
<p>
You need to run this in a separate terminal window while your blog is running and while the database is running. It makes connections to both to determine if your program works properly. Validate connects to localhost:8082 and expects that mongod is running on localhost on port 27017.
</p><p>
<i>Read if you want to run your blog on non-standard port, different host or connected to a mongod on  different server.</i>
</p><p>
<font size="-1">By popular demand, validate.py now takes some optional arguments that you can discover with the -h flag. These arguments will allow you to direct validate.py to make a connection to a web server at different port on a different host and connect to a mongod on a different host. You can also use a database name other than blog, a necessity if you are running on the free tier at MongoHW (for eg). I won't go into how these arguments work, as they are pretty self documenting. Note that to run the blog.py code to connect to a database outside of localhost (for example to a database at MongoHQ), you will need to make some global changes. </font>
</p><p>
This project requires Python 2.7. The code is not 3.0 compliant. 
</p><p>
Ok, once you get the blog posts working, validate.py will print out a validation code for HW 3.2. Please enter it below, exactly as shown with no spaces.
</p>
<customresponse>
<textbox rows='4' cols='50' correct_answer="hjkfd489hjkfhds8934kf23"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''hjkfd489hjkfhds8934kf23'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ENSoJLkZnkY'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 3.3' chapter_name='Week 3 - Schema Design' format='Homework' due='Nov 19 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:HPSgVT2BEYQ'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_3_3_problem' rerandomize='never' display_name='Homework: HW 3.3'>
<b>Making your blog accept comments</b>
<p>
In this homework  you will add code to your blog so that it accepts comments. You will be using the same code as you downloaded for HW 3.2.
</p><p>
Once again, the area where you need to work is marked with an XXX in the blog.py file. There are two locations. You don't need to figure out how to retrieve comments for this homework because the code you did in 3.2 already pulls the entire blog post (unless you specifically projected to eliminate the comments) and we gave you the code that pulls them out of the JSON document.
</p><p>
This assignment has fairly little code, but it's a little more subtle than the previous assignment because you are going to be manipulating an array within the Mongo document.  For the sake of clarity, here is a document out of the posts collection from a working project.
</p>
<pre>
{
	"_id" : ObjectId("509df76fbcf1bf5b27b4a23e"),
	"author" : "erlichson",
	"body" : "This is a blog entry",
	"comments" : [
		{
			"body" : "This is my comment",
			"author" : "Andrew Erlichson"
		},
		{
			"body" : "Give me liberty or give me death.",
			"author" : "Patrick Henry"
		}
	],
	"date" : ISODate("2012-11-10T06:42:55.733Z"),
	"permalink" : "This_is_a_blog_post_title",
	"tags" : [
		"cycling",
		"running",
		"swimming"
	],
	"title" : "This is a blog post title"
}
</pre>

<p>
Note that you add comments in this blog from the blog post detail page, which appears at 
<pre>
http://localhost:8082/post/post_slug
</pre>
where post_slug is the permalink. For the sake of eliminating doubt, the permalink for the example blog post above is http://localhost:8082/post/This_is_a_blog_post_title
</p><p>
You will run validation.py to check your work, much like the last problem. Validation.py will run through and check the requirements of HW 3.2 and then will check to make sure it can add blog comments, as required by this problem, HW 3.3. It checks the web output as well as the database documents.
</p>
<pre>
python validate.py
</pre>
<p>
Once you have the validation code, please copy and paste in the box below, no spaces. 
</p>
<customresponse>
<textbox rows='4' cols='50' correct_answer="dhfr48nf89jk093f9kj0d2d"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''dhfr48nf89jk093f9kj0d2d'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:po_TAFU4_3k'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-11-19T00:00' display_name='Week 4 - Performance'>
<sequential graded='false' display_name='Introduction' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:MA0QpaGggY8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Indexes' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pPnRWpL5zl4'/>
</vertical>
<problem showanswer='attempted' url_name='Indexes_problem' rerandomize='never' display_name='Quiz: Indexes'>
Which optimization will typically have the greatest impact on the performance of a database.
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Adding more memory so that the working set fits in memory.
</text></choice>
<choice location='bottom' correct='false'><text>Adding a faster drive so that operations that hit disk will happen more quickly.
</text></choice>
<choice location='bottom' correct='false'><text>Replacing your CPU with a faster one (say one 2x as fast)
</text></choice>
<choice location='bottom' correct='true'><text>Adding appropriate indexes on large collections so that only a small percentage of queries need to scan the collection.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:5Z6V8mJ8eS4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Creating Indexes' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:tRqenx45UAM'/>
</vertical>
<problem showanswer='attempted' url_name='Creating_Indexes_problem' rerandomize='never' display_name='Quiz: Creating Indexes'>
Please provide the mongo shell command to add an index to a collection named <i>students</i>, having the index  key be <i>class</i>, <i>student_name</i>. <customresponse>
<textbox rows='4' cols='50' correct_answer="db.students.ensureIndex({class:1, student_name:1})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.students.ensureIndex({class:1, student_name:1})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:h1VdrcOjFm8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Discovering indexes' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:hH7kYu_-FXg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multikey Indexes' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:JO_puGONaLc'/>
</vertical>
<problem showanswer='attempted' url_name='Multikey_Indexes_problem' rerandomize='never' display_name='Quiz: Multikey Indexes'>
Suppose we have a collection <i>foo</i> that has an index created as follows:
<pre>
db.foo.ensureIndex({a:1, b:1})
</pre>
Which of the following inserts are valid to this collection?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>db.foo.insert({a:["apples","oranges"], b:"grapes"})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.insert({a:"grapes", b:"oranges"})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.insert({a:"grapes", b:[8,9,10]})<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.foo.insert({a:[1,2,3], b:[5,6,7]})<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:CeE6hZ90Uzk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Multikey Continued' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:mPSGG2p33RQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation option, Unique' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:764mQG1iL8E'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_option_Unique_problem' rerandomize='never' display_name='Quiz: Index Creation option, Unique'>
Please provide the mongo shell command to add a unique index to the collection <i>students</i> on the keys <i>student_id</i>, <i>class_id</i>.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.students.ensureIndex({student_id:1, class_id:1}, {unique:true})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.students.ensureIndex({student_id:1, class_id:1}, {unique:true})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:cCO7b-fcj0I'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation, Removing Dups' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:YJaWPXNGvoU'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_Removing_Dups_problem' rerandomize='never' display_name='Quiz: Index Creation, Removing Dups'>
If you choose the dropDups option when creating a unique index, what will the MongoDB do to documents that conflict with an existing index entry? <multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Move them to an archive collection.</text></choice>
<choice location='bottom' correct='false'><text>Unset the conflicting key so that they can be indexed and remain in the collection.</text></choice>
<choice location='bottom' correct='false'><text>Remove them but write the deleted documents in JSON to a special file in the log directory.</text></choice>
<choice location='bottom' correct='true'><text>Delete them for ever and ever, Amen.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:s46y1rJAvVs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation, Sparse' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:s4sYwLndtTI'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_Sparse_problem' rerandomize='never' display_name='Quiz: Index Creation, Sparse'>
Suppose you had the following documents in a collection called <i>people</i> with the following docs:
<pre>
> db.people.find()
{ "_id" : ObjectId("50a464fb0a9dfcc4f19d6271"), "name" : "Andrew", "title" : "Jester" }
{ "_id" : ObjectId("50a4650c0a9dfcc4f19d6272"), "name" : "Dwight", "title" : "CEO" }
{ "_id" : ObjectId("50a465280a9dfcc4f19d6273"), "name" : "John" }
</pre>
And there is an index defined as follows:
<pre>
db.people.ensureIndex({title:1}, {sparse:1})
</pre>
If you perform the following query, what do you get back, and why?
<pre>
db.people.find({title:null})
</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>No documents, because the query uses the index and there are no documents with title:null in the index.</text></choice>
<choice location='bottom' correct='false'><text>No documents, because querying for title:null only finds documents that explicitly have title:null, regardless of the index.</text></choice>
<choice location='bottom' correct='false'><text>The document for John, because the query won't use the index. </text></choice>
<choice location='bottom' correct='false'><text>All the documents in the collection, because title:null matches all documents.</text></choice>
<choice location='bottom' correct='false'><text>The document for John, because the ensureIndex command won't succeed in this case.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:_MJYRlianas'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Creation, Background' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:28wCvoXmY7A'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Creation_Background_problem' rerandomize='never' display_name='Quiz: Index Creation, Background'>
Which things are true about creating an index in the background in MongoDB. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>A mongod instance can only build one background index at a time per database.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Although the database server will continue to take requests, a background index creation still blocks the mongo shell that you are using to create the index.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Creating an index in the background takes longer than creating it in the foreground<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>In Mongo 2.2 and above, indexes are created in the background by default.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:aNSHjG_LnSc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using Explain' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:inmABt5RKf0'/>
<html>
<h2>Lecture Notes</h2>
At 7 minutes into this lecture, there is a mistake. I used $or versus $and and the results was that the query returned all 10,000 documents. Either way, it would have scanned 10,000 documents, because the query could not use the index, but the n value would have been lower had the query been correct. In the lecture, I explain away the wrong n value as having to do with the match phase of the query not using an index, but this is wrong. The n value is the number of documents returned by the query and had I formed the query correctly, it would have been approximately 250.</html>
</vertical>
<problem showanswer='attempted' url_name='Using_Explain_problem' rerandomize='never' display_name='Quiz: Using Explain'>
Given the following output from explain, what is the best description of what happened during the query?
<pre>
{
	"cursor" : "BasicCursor",
	"isMultiKey" : false,
	"n" : 100000,
	"nscannedObjects" : 10000000,
	"nscanned" : 10000000,
	"nscannedObjectsAllPlans" : 10000000,
	"nscannedAllPlans" : 10000000,
	"scanAndOrder" : false,
	"indexOnly" : false,
	"nYields" : 7,
	"nChunkSkips" : 0,
	"millis" : 5151,
	"indexBounds" : {
		
	},
	"server" : "Andrews-iMac.local:27017"
}

</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>The query used an index called BasicCursor and returned in a 5151 microseconds</text></choice>
<choice location='bottom' correct='true'><text>The query scanned 10,000,000 documents, returning 100,000 in 5.2 seconds.</text></choice>
<choice location='bottom' correct='false'><text>The query scanned 100,000 documents and return in 5 milliseconds.</text></choice>
<choice location='bottom' correct='false'><text>The query was able to use a covered index to answer the query entirely within the index without looking at the documents.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Gpj_s49H_rQ'/>
</vertical>
</sequential>
<sequential graded='false' display_name='When is an index used?' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Lwms58Y_3Jc'/>
</vertical>
<problem showanswer='attempted' url_name='When_is_an_index_used__problem' rerandomize='never' display_name='Quiz: When is an index used?'>
Given collection foo with the following index:
<pre>
db.foo.ensureIndex({a:1, b:1, c:1})
</pre>
Which of the following queries will use the index?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>db.foo.find({b:3, c:4})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.find({a:3})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.foo.find({c:1}).sort({a:1, b:1})<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.foo.find({c:1}).sort({a:-1, b:1})<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:imHqsvqx-GA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='How large is your index?' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:oywrqWNY46s'/>
</vertical>
<problem showanswer='attempted' url_name='How_large_is_your_index__problem' rerandomize='never' display_name='Quiz: How large is your index?'>
Is it more important that your index or your data fit into memory?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>Index</text></choice>
<choice location='bottom' correct='false'><text>Data</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:mXHUIghDkFw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Cardinality' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:xiujksUfzUA'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Cardinality_problem' rerandomize='never' display_name='Quiz: Index Cardinality'>
Let's say you update a document with a key called tags and that update causes the document to need to get moved on disk. If the document has 100 tags in it, and if the tags array is indexed with a multikey index, how many index points need to be updated in the index to accomodate the move? Put just the number below.<customresponse>
<textbox rows='4' cols='50' correct_answer="100"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''100'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4UW_oMSswTo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Index Selectivity' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:On8HHR1agsI'/>
</vertical>
<problem showanswer='attempted' url_name='Index_Selectivity_problem' rerandomize='never' display_name='Quiz: Index Selectivity'>
Given the following attributes of automobiles: color, weight, manufacturer, odometer mileage, which index is likely be the most selective, provided you can provide all four attributes on a search:<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Color</text></choice>
<choice location='bottom' correct='false'><text>Weight</text></choice>
<choice location='bottom' correct='false'><text>Manufacturer</text></choice>
<choice location='bottom' correct='true'><text>Odometer Mileage</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:BT95omWR2nw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hinting an Index' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ksOn-SkaIcg'/>
</vertical>
<problem showanswer='attempted' url_name='Hinting_an_Index_problem' rerandomize='never' display_name='Quiz: Hinting an Index'>
Given the following data in a collection:
<pre>
> db.people.find()
{ "_id" : ObjectId("50a464fb0a9dfcc4f19d6271"), "name" : "Andrew", "title" : "Jester" }
{ "_id" : ObjectId("50a4650c0a9dfcc4f19d6272"), "name" : "Dwight", "title" : "CEO" }
{ "_id" : ObjectId("50a465280a9dfcc4f19d6273"), "name" : "John" }
</pre>
and the following indexex:
<pre>
> db.people.getIndexes()
[
	{
		"v" : 1,
		"key" : {
			"_id" : 1
		},
		"ns" : "test.people",
		"name" : "_id_"
	},
	{
		"v" : 1,
		"key" : {
			"title" : 1
		},
		"ns" : "test.people",
		"name" : "title_1",
		"sparse" : 1
	}
]
</pre>
Which query below will return the most documents.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>db.people.find().sort({'title':1}).hint({$natural:1})</text></choice>
<choice location='bottom' correct='false'><text>db.people.find().sort({'title':1})</text></choice>
<choice location='bottom' correct='false'><text>db.people.find({name:{$ne:"Kevin"}}).sort({'title':1})</text></choice>
<choice location='bottom' correct='false'><text>db.people.find({'title':{$ne:null}}).hint({'title':1})
</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:WHc_qRSxGM0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Hinting in Pymongo' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:dlKcfo7WtGU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Efficiency of Index Use' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:1sADN-NKwhY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Geospatial Indexes' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:UKUDYqNVL6I'/>
</vertical>
<problem showanswer='attempted' url_name='Geospatial_Indexes_problem' rerandomize='never' display_name='Quiz: Geospatial Indexes'>
Suppose you have a 2D geospatial index defined on the key <i>location</i> in the collection <i>places</i>. Write a query that will find the closest three places (the closest three documents) to the location 74, 140.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.places.find( { location : { $near : [74,140] } }).limit(3)&#10;"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.places.find( { location : { $near : [74,140] } }).limit(3)
'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:hVLa0H7Oe98'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Geospacial Spherical' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:vY3_H4MzkIY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Logging Slow Queries' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:aWuvC-O7Qkk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Profiling' chapter_name='Week 4 - Performance' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:pN1Yhrup9-I'/>
</vertical>
<problem showanswer='attempted' url_name='Profiling_problem' rerandomize='never' display_name='Quiz: Profiling'>
Write the query to look in the system profile collection for all queries that took longer than one second, ordered by timestamp descending.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.system.profile.find({millis:{$gt:1000}}).sort({ts:-1})"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.system.profile.find({millis:{$gt:1000}}).sort({ts:-1})'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:A4x4kE02pSc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongotop' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:D9YLXgy7NYo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mongostat' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:eLWQO_AJmrI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Sharding Overview' chapter_name='Week 4 - Performance'>
<vertical>
<video display_name='Lecture' youtube='1.0:BDxT-VZdYqc'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 4.1' chapter_name='Week 4 - Performance' format='Homework' due='Nov 26 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:0tpXSPgYk4I'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_4_1_problem' rerandomize='never' display_name='Homework: HW 4.1'>
Suppose you have a collection with the following indexes:
<pre>
> db.products.getIndexes()
[
	{
		"v" : 1,
		"key" : {
			"_id" : 1
		},
		"ns" : "store.products",
		"name" : "_id_"
	},
	{
		"v" : 1,
		"key" : {
			"sku" : 1,
			"unique" : true
		},
		"ns" : "store.products",
		"name" : "sku_1_unique_true"
	},
	{
		"v" : 1,
		"key" : {
			"price" : -1
		},
		"ns" : "store.products",
		"name" : "price_-1"
	},
	{
		"v" : 1,
		"key" : {
			"description" : 1
		},
		"ns" : "store.products",
		"name" : "description_1"
	},
	{
		"v" : 1,
		"key" : {
			"category" : 1,
			"brand" : 1
		},
		"ns" : "store.products",
		"name" : "category_1_brand_1"
	},
	{
		"v" : 1,
		"key" : {
			"reviews.author" : 1
		},
		"ns" : "store.products",
		"name" : "reviews.author_1"
	}

</pre>
Which of the following queries can utilize an index. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>db.products.find({'brand':"GE"})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.products.find({'brand':"GE"}).sort({price:1})<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>db.products.find({$and:[{price:{$gt:30}},{price:{$lt:50}}]}).sort({brand:1})<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>db.products.find({brand:'GE'}).sort({category:1, brand:-1}).explain()<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ecMrwMMBqIg'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 4.2' chapter_name='Week 4 - Performance' format='Homework' due='Nov 26 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:Zz8TerE95Ss'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_4_2_problem' rerandomize='never' display_name='Homework: HW 4.2'>
Suppose you have a collection called <i>tweets</i> whose documents contain information about the <i>created_at</i> time of the tweet and the user's <i>followers_count</i> at the time they issued the tweet. What can you infer from the following <i>explain</i> output?

<pre>
db.tweets.find({"user.followers_count":{$gt:1000}}).sort({"created_at" : 1 }).limit(10).skip(5000).explain()
{
        "cursor" : "BtreeCursor created_at_-1 reverse",
        "isMultiKey" : false,
        "n" : 10,
        "nscannedObjects" : 46462,
        "nscanned" : 46462,
        "nscannedObjectsAllPlans" : 49763,
        "nscannedAllPlans" : 49763,
        "scanAndOrder" : false,
        "indexOnly" : false,
        "nYields" : 0,
        "nChunkSkips" : 0,
        "millis" : 205,
        "indexBounds" : {
                "created_at" : [
                        [
                                {
                                        "$minElement" : 1
                                },
                                {
                                        "$maxElement" : 1
                                }
                        ]
                ]
        },
        "server" : "localhost.localdomain:27017"
}
</pre><choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>This query performs a collection scan.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The query uses an index to determine the order in which to return result documents.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query uses an index to determine which documents match.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query returns 46462 documents.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The query visits 46462 documents.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query is a "covered index query".<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:LrsbQkNztMY'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 4.3' chapter_name='Week 4 - Performance' format='Homework' due='Nov 26 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:K-oXNC7voR8'/>
</vertical>
<problem showanswer='due' attempts='3' url_name='HW_4_3_problem' rerandomize='never' display_name='Homework: HW 4.3'>
<b>Making the Blog fast</b>
<p>Please download <a href="/static/handouts/hw4-3.tar">hw4-3.tar</a> (mac) or <a href="/static/handouts/hw4-3.zip">hw4-3.zip</a> (pc) to get started. This assignment requires Mongo 2.2 or above. </p>

<p>In this homework assignment you will be adding some indexes to the post collection to make the blog fast.</p>

<p>We have provided the full code for the blog application and you don't need to make any changes, or even run the blog. But you can, for fun.</p>

<p>We are also providing a patriotic (if you are an American) data set for the blog. There are 1000 entries with lots of comments and tags. You must load this dataset to complete the problem.</p>
<pre>
# from the mongo shell
use blog
db.posts.drop()
# from the a mac or PC terminal window
mongoimport -d blog -c posts &lt; posts.json
</pre>
<p>
The blog has been enhanced so that it can also display the top 10 most recent posts by tag. There are hyperlinks from the post tags to the page that displays the 10 most recent blog entries for that tag. (run the blog and it will be obvious)
</p><p>
Your assignment is to make the following blog pages fast:
</p>
<ul>
<li>The blog home page</li>
<li>The page that displays blog posts by tag (http://localhost:8082/tag/whatever)</li>
<li>The page that displays a blog entry by permalink (http://localhost:8082/post/permalink)</li>
</ul>
By fast, we mean that indexes should be in place to satisfy these queries such that we only need to scan the number of documents we are going to return.

<p>
To figure out what queries you need to optimize,  you can read the blog.py code and see what it does to display those pages. Isolate those queries and use explain to explore.
</p><p>
Once you have added the indexes to make those pages fast run the following.
</p>
<pre>
python validate.py
</pre>
(note that for folks who are using MongoLabs or MongoHQ there are some command line options to validate.py to make it possible to use those services)
Now enter the validation code below. 
<customresponse>
<textbox rows='4' cols='50' correct_answer="nffhe89hfkdjsbapajsfda89jks"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''nffhe89hfkdjsbapajsfda89jks'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pDtSL7gbQa4'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 4.4' chapter_name='Week 4 - Performance' format='Homework' due='Nov 26 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_4_4_problem' rerandomize='never' display_name='Homework: HW 4.4'>
In this problem you will analyze a profile log taken from a mongoDB instance. To start, please download <a href="/static/handouts/sysprofile.json"> sysprofile.json</a> and import it with the following command:

<pre>
mongoimport -d m101 -c profile &lt; sysprofile.json
</pre>

Now query the profile data, looking for all queries to the <i>students</i> collection in the database <i>school2</i>, sorted in order of decreasing latency. What is the latency of the longest running operation to the collection, in milliseconds?
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>4715</text></choice>
<choice location='bottom' correct='false'><text>34430</text></choice>
<choice location='bottom' correct='false'><text>5018</text></choice>
<choice location='bottom' correct='true'><text>15820</text></choice>
<choice location='bottom' correct='false'><text>3217</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
</chapter>
<chapter start='2012-11-26T00:00' display_name='Week 5 - Aggregation' hide_answer_status_until_due='False'>
<sequential graded='false' display_name='Introduction to Aggregation' chapter_name='Week 5 - Aggregation'>
<vertical>
<video display_name='Lecture' youtube='1.0:EaEIHm3CMQM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Simple Aggregation Example' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:T2BX-LZOYsY'/>
</vertical>
<problem showanswer='attempted' url_name='Simple_Aggregation_Example_problem' rerandomize='never' display_name='Quiz: Simple Aggregation Example'>
Write the aggregation query that will find the number of products by category of a collection that has the form:
<pre>
{
	"_id" : ObjectId("50b1aa983b3d0043b51b2c52"),
	"name" : "Nexus 7",
	"category" : "Tablets",
	"manufacturer" : "Google",
	"price" : 199
}

</pre>
Have the resulting key be called "num_products," as in the video lesson. 
Hint, you just need to change which key you are aggregating on relative to the examples shown in the lesson.
<p>
Please double quote all keys to make it easier to check your result.
</p>
<customresponse>
<textbox rows='4' cols='50' correct_answer='db.products.aggregate([{$group:{"_id":"$category", "num_products":{"$sum":1}}}])&#10;'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.products.aggregate([{$group:{"_id":"$category", "num_products":{"$sum":1}}}])
'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Nt0cQI86G40'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Aggregation Pipeline' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:WazN2DS8s8c'/>
</vertical>
<problem showanswer='attempted' url_name='The_Aggregation_Pipeline_problem' rerandomize='never' display_name='Quiz: The Aggregation Pipeline'>
Which of the following are stages in the aggregation pipeline. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Match<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Transpose<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Group<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Skip<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Limit<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Sort<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Project<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>unwind<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:mcnGfI69rRc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Simple Example Expanded' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:3lEpnMcfpCs'/>
<html>
<h2>Lecture Notes</h2>

</html>
</vertical>
<problem showanswer='attempted' url_name='Simple_Example_Expanded_problem' rerandomize='never' display_name='Quiz: Simple Example Expanded'>
If you have the following collection of stuff:
<pre>
> db.stuff.find()
{ "_id" : ObjectId("50b26f9d80a78af03b5163c8"), "a" : 1, "b" : 1, "c" : 1 }
{ "_id" : ObjectId("50b26fb480a78af03b5163c9"), "a" : 2, "b" : 2, "c" : 1 }
{ "_id" : ObjectId("50b26fbf80a78af03b5163ca"), "a" : 3, "b" : 3, "c" : 1 }
{ "_id" : ObjectId("50b26fcd80a78af03b5163cb"), "a" : 3, "b" : 3, "c" : 2 }
{ "_id" : ObjectId("50b26fd380a78af03b5163cc"), "a" : 3, "b" : 5, "c" : 3 }
</pre>
and you perform the following aggregation:
<pre>
db.stuff.aggregate([{$group:{_id:'$c'}}])
</pre>
How many documents will be in the result set from aggregate?
<p>
</p><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>1</text></choice>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='true'><text>3</text></choice>
<choice location='bottom' correct='false'><text>4</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:nr1E1qTyIHU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Compound Grouping' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:LPFVRrag2Zg'/>
</vertical>
<problem showanswer='attempted' url_name='Compound_Grouping_problem' rerandomize='never' display_name='Quiz: Compound Grouping'>
Given the following collection:
<pre>
> db.stuff.find()
{ "_id" : ObjectId("50b26f9d80a78af03b5163c8"), "a" : 1, "b" : 1, "c" : 1 }
{ "_id" : ObjectId("50b26fb480a78af03b5163c9"), "a" : 2, "b" : 2, "c" : 1 }
{ "_id" : ObjectId("50b26fbf80a78af03b5163ca"), "a" : 3, "b" : 3, "c" : 1 }
{ "_id" : ObjectId("50b26fcd80a78af03b5163cb"), "a" : 3, "b" : 3, "c" : 2 }
{ "_id" : ObjectId("50b26fd380a78af03b5163cc"), "a" : 3, "b" : 5, "c" : 3 }
{ "_id" : ObjectId("50b27f7080a78af03b5163cd"), "a" : 3, "b" : 3, "c" : 2 }
</pre>
And the following aggregation query:
<pre>
db.stuff.aggregate([{$group:
		     {_id:
		      {'moe':'$a', 
		       'larry':'$b',
		       'curly':'$c'
		      }
		     }
		    }])
</pre>
How many documents will be in the result set?

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>3</text></choice>
<choice location='bottom' correct='false'><text>4</text></choice>
<choice location='bottom' correct='true'><text>5</text></choice>
<choice location='bottom' correct='false'><text>6</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:bIlwnlYBRA0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using a document for _id' chapter_name='Week 5 - Aggregation'>
<vertical>
<video display_name='Lecture' youtube='1.0:zoN4cj_XQzY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Aggregation Expressions' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:L4G14MTfTgQ'/>
</vertical>
<problem showanswer='attempted' url_name='Aggregation_Expressions_problem' rerandomize='never' display_name='Quiz: Aggregation Expressions'>
Which of the following aggregation expressions must be used in conjunction with a sort to make any sense?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>$addToSet<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>$first<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>$last<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>$max<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>$min<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>$avg<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>$push<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>$sum<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:kJ0k2na4ukU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $sum' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:oAV9tC0R8xk'/>
<html>
<h2>Lecture Notes</h2>
Write an aggregation expression that adds up</html>
</vertical>
<problem showanswer='attempted' url_name='Using_sum_problem' rerandomize='never' display_name='Quiz: Using $sum'>
<i>This problem, and some after it, use the zips collection from <a href="http://media.mongodb.org/zips.json">media.mongodb.org/zips.json</a>. You don't need to download it, but you can if you want, allowing you to test your queries within MongoDB. You can import, once downloaded, using mongoimport</i>
<p>
Suppose we have a collection of populations by postal code. The postal codes in are in the _id field, and are therefore unique. Documents look like this:</p>
<pre>
{
	"city" : "CLANTON",
	"loc" : [
		-86.642472,
		32.835532
	],
	"pop" : 13990,
	"state" : "AL",
	"_id" : "35045"
}
</pre>
<i>For students outside the United States, there are 50 non-overlapping states in the US with two letter abbreviations such as NY and CA.  In addition, the capital of Washington is within an area designated the District of Columbia, and carries the abbreviation DC. For purposes of the mail, the postal service considers DC to be a "state." So in this dataset, there are 51 states. We call postal codes "zip codes." A city may overlap several zip codes.</i>
<p>
Write an aggregation query to sum up the population (pop) by state and put the result in a field called population. Don't use a compound _id key (you don't need one and the quiz checker is not expecting one). The collection name is zips. so something along the lines of db.zips.aggregrate...
</p><customresponse>
<textbox rows='4' cols='50' correct_answer='db.zips.aggregate([{"$group":{"_id":"$state", "population":{$sum:"$pop"}}}])'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{"$group":{"_id":"$state", "population":{$sum:"$pop"}}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ATO_s_Ah08o'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $avg' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:7UWOK8rWf1w'/>
</vertical>
<problem showanswer='attempted' url_name='Using_avg_problem' rerandomize='never' display_name='Quiz: Using $avg'>
<i>This problem uses the same dataset as we described in using $sum quiz and you should review that quiz if you did not complete it.</i><p>
Given population data by zip code (postal code) that looks like this:</p>
<pre>
{
	"city" : "FISHERS ISLAND",
	"loc" : [
		-72.017834,
		41.263934
	],
	"pop" : 329,
	"state" : "NY",
	"_id" : "06390"
}
</pre>
Write an aggregation expression to calculate the average population of a zip code (postal code) by state. As before, the postal code is in the _id field and is unique.  The collection is assumed to be called "zips" and you should name the key in the result set "average_pop".
<customresponse>
<textbox rows='4' cols='50' correct_answer='db.zips.aggregate([{"$group":{"_id":"$state", "average_pop":{"$avg":"$pop"}}}])'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{"$group":{"_id":"$state", "average_pop":{"$avg":"$pop"}}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:tT6Jx8s9dTc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $addToSet' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:y2FD4R3in5U'/>
</vertical>
<problem showanswer='attempted' url_name='Using_addToSet_problem' rerandomize='never' display_name='Quiz: Using $addToSet'>
<i>This problem uses the same zip code data as the $using sum quiz. See that quiz for a longer explanation.</i>
<p>
Suppose we population by zip code (postal code) data that looks like this (putting in a query for the zip codes in Palo Alto)
</p>
<pre>
> db.zips.find({state:"CA",city:"PALO ALTO"})
{ "city" : "PALO ALTO", "loc" : [ -122.149685, 37.444324 ], "pop" : 15965, "state" : "CA", "_id" : "94301" }
{ "city" : "PALO ALTO", "loc" : [ -122.184234, 37.433424 ], "pop" : 1835, "state" : "CA", "_id" : "94304" }
{ "city" : "PALO ALTO", "loc" : [ -122.127375, 37.418009 ], "pop" : 24309, "state" : "CA", "_id" : "94306" }
</pre>
Write an aggregation query that will return the postal codes that cover each city. The results should look like this:
<pre>
		{
			"_id" : "CENTREVILLE",
			"postal_codes" : [
				"22020",
				"49032",
				"39631",
				"21617",
				"35042"
			]
		},
</pre>
Again the collection will be called zips. You can deduce what your result column names should be from the above output. (ignore the issue that a city may have the same name in two different states and is in fact two different cities in that case - for eg Springfield, MO and Springfield, MA)<customresponse>
<textbox rows='4' cols='50' correct_answer='db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}])'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:zGcTxUQuLGE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $push' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:gjIVUFufx3A'/>
</vertical>
<problem showanswer='attempted' url_name='Using_push_problem' rerandomize='never' display_name='Quiz: Using $push'>
Given the zipcode dataset (explained more fully in the using $sum quiz) that has documents that look like this:
<pre>
> db.zips.findOne()
{
	"city" : "ACMAR",
	"loc" : [
		-86.51557,
		33.584132
	],
	"pop" : 6055,
	"state" : "AL",
	"_id" : "35004"
}

</pre>
would you expect the following two queries to produce the same result or different results? 
<pre>
db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$push":"$_id"}}}])
</pre>
<pre>
db.zips.aggregate([{"$group":{"_id":"$city", "postal_codes":{"$addToSet":"$_id"}}}])
</pre><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>Same result</text></choice>
<choice location='bottom' correct='false'><text>Different Result</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:hFqDvVXtm6E'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Using $max and $min' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:BYoNX4trjOQ'/>
</vertical>
<problem showanswer='attempted' url_name='Using_max_and_min_problem' rerandomize='never' display_name='Quiz: Using $max and $min'>
Again thinking about the zip code database, write an aggregation query that will return the population of the postal code in each state with the highest population. It should return output that looks like this:
<pre>
{
			"_id" : "WI",
			"pop" : 57187
		},
		{
			"_id" : "WV",
			"pop" : 70185
		},
..and so on
</pre>
Once again, the collection is named zips.<customresponse>
<textbox rows='4' cols='50' correct_answer='db.zips.aggregate([{$group:{"_id":"$state", pop:{$max:"$pop"}}}])'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{$group:{"_id":"$state", pop:{$max:"$pop"}}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:sHCdOiCispA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Double $group stages' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ET4ubwQTTos'/>
</vertical>
<problem showanswer='attempted' url_name='Double_group_stages_problem' rerandomize='never' display_name='Quiz: Double $group stages'>
Given the following collection:
<pre>
> db.fun.find()
{ "_id" : 0, "a" : 0, "b" : 0, "c" : 21 }
{ "_id" : 1, "a" : 0, "b" : 0, "c" : 54 }
{ "_id" : 2, "a" : 0, "b" : 1, "c" : 52 }
{ "_id" : 3, "a" : 0, "b" : 1, "c" : 17 }
{ "_id" : 4, "a" : 1, "b" : 0, "c" : 22 }
{ "_id" : 5, "a" : 1, "b" : 0, "c" : 5 }
{ "_id" : 6, "a" : 1, "b" : 1, "c" : 87 }
{ "_id" : 7, "a" : 1, "b" : 1, "c" : 97 }

</pre>
And the following aggregation query
<pre>
db.fun.aggregate([{$group:{_id:{a:"$a", b:"$b"}, c:{$max:"$c"}}}, {$group:{_id:"$_id.a", c:{$min:"$c"}}}])
</pre>
What values are returned?
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>17 and 54</text></choice>
<choice location='bottom' correct='false'><text>97 and 21</text></choice>
<choice location='bottom' correct='false'><text>54 and 5</text></choice>
<choice location='bottom' correct='true'><text>52 and 22</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:J-asAAEHJ0Q'/>
</vertical>
</sequential>
<sequential graded='false' display_name='$project' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:yi-ySSNO8Ao'/>
</vertical>
<problem showanswer='attempted' url_name='_project_problem' rerandomize='never' display_name='Quiz: $project'>
Write an aggregation query with a single projection stage that will transform the documents in the zips collection from this:
<pre>
{
	"city" : "ACMAR",
	"loc" : [
		-86.51557,
		33.584132
	],
	"pop" : 6055,
	"state" : "AL",
	"_id" : "35004"
}

</pre>

to documents in the result set that look like this:
<pre>
{
	"city" : "acmar",
	"pop" : 6055,
	"state" : "AL",
	"zip" : "35004"
}
</pre>
So that the checker works properly, please specify what you want to do with the _id key as the first item. The other items should be ordered as above. As before, assume the collection is called zips. You are running only the projection part of the pipeline for this quiz.
<br/>
<br/>
<i>A few facts not mentioned in the lesson that you will need to know to get this right: If you don't mention a key, it is not included, except for _id, which must be explicitly suppressed. If you want to include  a key exactly as it is named in the source document, you just write key:1, where key is the name of the key. You will probably get more out of this quiz is you download the zips.json file and practice in the shell. zips.json link is in the using $sum quiz</i>
<customresponse>
<textbox rows='4' cols='50' correct_answer='db.zips.aggregate([{$project:{_id:0, city:{$toLower:"$city"}, pop:1, state:1, zip:"$_id"}}])'> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{$project:{_id:0, city:{$toLower:"$city"}, pop:1, state:1, zip:"$_id"}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:IGN0lXg-kJ0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='$match' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:qohLRL8k0So'/>
</vertical>
<problem showanswer='attempted' url_name='_match_problem' rerandomize='never' display_name='Quiz: $match'>
Again, thinking about the zipcode collection, write an aggregation query with a single match phase that filters for zipcodes with greater than 100,000 people.  You may need to look up the use of the <a href="http://docs.mongodb.org/manual/reference/operators/">$gt operator in the MongoDB docs</a>.
<br/>
<br/>
Assume the collection is called zips.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.zips.aggregate([{$match:{pop:{$gt:100000}}}])"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{$match:{pop:{$gt:100000}}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:CHGiumXE-pU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='$sort' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:TW1KByIuns4'/>
</vertical>
<problem showanswer='attempted' url_name='_sort_problem' rerandomize='never' display_name='Quiz: $sort'>
Again, considering the zipcode collection, which has documents that look like this, 
<pre>
{
	"city" : "ACMAR",
	"loc" : [
		-86.51557,
		33.584132
	],
	"pop" : 6055,
	"state" : "AL",
	"_id" : "35004"
}

</pre>
Write an aggregation query with just a sort stage to sort by (state, city), both ascending. Assume the collection is called zips.<customresponse>
<textbox rows='4' cols='50' correct_answer="db.zips.aggregate([{$sort:{state:1, city:1}}])"> </textbox>

<answer type='loncapa/python'><![CDATA[
try:
  response = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  response = '0'
answer = '''db.zips.aggregate([{$sort:{state:1, city:1}}])'''

# Filter out newlines, carriage returns, and semicolons.
import demjson
import re
response = re.sub(r'[\s;]+', '', response)
answer = re.sub(r'[\s;]+', '', answer)

# Create a JSON string representation of the input string.
def json_encode(text):
  import demjson
  import re

  # The global scope is not carried here, so we must internally define functions.
  class Match(object):
    start = 0
    end = 0
    def __init__(self, start, end):
      self.start = start
      self.end = end

  # Extract embedded JSON.
  def capture(text, start):
    pos = start
    match = Match(-1, -1)
    brace_count = 0
    while pos < len(text):
      if text[pos] == '{':
        # Start checking for a JSON object.
        if brace_count == 0:
          match.start = pos
        brace_count = brace_count + 1
      elif text[pos] == '}':
        # Check for a complete JSON object.
        brace_count = brace_count - 1
        if brace_count == 0:
          match.end = pos + 1
          match.str = text[match.start : match.end]
          break
      pos = pos + 1
    if match.start == -1 or match.end == -1:
      return None
    return match

  # Now perform actual answer-to-json conversion.
  text_out = '{'
  key_index_out = 0
  # Start parsing and splitting the string.
  pos = 0
  match = capture(text, pos)
  while match != None:
    # There was some text between matches, capture it.
    if pos != match.start:
      text_out += '"s' + str(key_index_out) + '" : "' +         re.sub('"', '', text[pos:match.start]) + '", '
      key_index_out = key_index_out + 1
    text_out += '"s' + str(key_index_out) + '" : ' + match.str + ', '
    key_index_out = key_index_out + 1
    pos = match.end
    match = capture(text, pos)
  # Get any text after the last match.
  text_out += '"s' + str(key_index_out) + '" : "' +     re.sub('"', '', text[pos:]) + '", '
  text_out += '}'
  return str(text_out)

correct = ['incorrect']
messages = ['']

try:
  response_json = demjson.decode(json_encode(response))
  answer_json = demjson.decode(json_encode(answer))
  if response_json == answer_json:
    correct[0] = 'correct'
except demjson.JSONDecodeError as err:
  messages[0] = "Response failed to parse " + str(err)
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:-cghyd6AHHA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='$limit and $skip' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:AdxoEzVqdtc'/>
</vertical>
<problem showanswer='attempted' url_name='_limit_and_skip_problem' rerandomize='never' display_name='Quiz: $limit and $skip'>
Suppose you change the order of skip and limit in the query shown in the lesson, to look like this:
<pre>
db.zips.aggregate([
    {$match:
     {
	 state:"NY"
     }
    },
    {$group:
     {
	 _id: "$city",
	 population: {$sum:"$pop"},
     }
    },
    {$project:
     {
	 _id: 0,
	 city: "$_id",
	 population: 1,
     }
    },
    {$sort:
     {
	 population:-1
     }
    },
    {$limit: 5},
    {$skip: 10} 
])

</pre>

How many documents do you think will be in the result set?
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>10</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
<choice location='bottom' correct='true'><text>0</text></choice>
<choice location='bottom' correct='false'><text>100</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:joRw-fqCIWA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Revisiting $first and $last' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:O1zeqAxdUgk'/>
</vertical>
<problem showanswer='attempted' url_name='Revisiting_first_and_last_problem' rerandomize='never' display_name='Quiz: Revisiting $first and $last'>
Given the following collection:
<pre>
> db.fun.find()
{ "_id" : 0, "a" : 0, "b" : 0, "c" : 21 }
{ "_id" : 1, "a" : 0, "b" : 0, "c" : 54 }
{ "_id" : 2, "a" : 0, "b" : 1, "c" : 52 }
{ "_id" : 3, "a" : 0, "b" : 1, "c" : 17 }
{ "_id" : 4, "a" : 1, "b" : 0, "c" : 22 }
{ "_id" : 5, "a" : 1, "b" : 0, "c" : 5 }
{ "_id" : 6, "a" : 1, "b" : 1, "c" : 87 }
{ "_id" : 7, "a" : 1, "b" : 1, "c" : 97 }
</pre>
What would be the value of c in the result from this aggregation query
<pre>
db.fun.aggregate([
    {$match:{a:0}},
    {$sort:{c:-1}}, 
    {$group:{_id:"$a", c:{$first:"$c"}}}
])
</pre>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>21</text></choice>
<choice location='bottom' correct='true'><text>54</text></choice>
<choice location='bottom' correct='false'><text>97</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:WBWb0ssDVeY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='$unwind' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:E4aYOQPeQvI'/>
</vertical>
<problem showanswer='attempted' url_name='_unwind_problem' rerandomize='never' display_name='Quiz: $unwind'>
Suppose you have the following collection:
<pre>
db.people.find()
{ "_id" : "Barack Obama", "likes" : [ "social justice", "health care", "taxes" ] }
{ "_id" : "Mitt Romney", "likes" : [ "a balanced budget", "corporations", "binders full of women" ] }
</pre>
And you unwind the "likes" array of each document. How many documents will you wind up with?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>4</text></choice>
<choice location='bottom' correct='true'><text>6</text></choice>
<choice location='bottom' correct='false'><text>9</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:Xfl3m7wz8ts'/>
</vertical>
</sequential>
<sequential graded='false' display_name='$unwind example' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:XiWCJr4Lqag'/>
</vertical>
<problem showanswer='attempted' url_name='_unwind_example_problem' rerandomize='never' display_name='Quiz: $unwind example'>
Which grouping operator will enable to you to reverse the effects of an unwind?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>$sum</text></choice>
<choice location='bottom' correct='false'><text>$addToSet</text></choice>
<choice location='bottom' correct='true'><text>$push</text></choice>
<choice location='bottom' correct='false'><text>$first</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:jAWL-BJD0tI'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Double $unwind' chapter_name='Week 5 - Aggregation' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:sgnidsHyFeU'/>
</vertical>
<problem showanswer='attempted' url_name='Double_unwind_problem' rerandomize='never' display_name='Quiz: Double $unwind'>
Can you reverse the effects of a double unwind (2 unwinds in a row) in our inventory collection (shown in the lesson ) with the $push operator?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>Yes</text></choice>
<choice location='bottom' correct='false'><text>No</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:pziFq1oVRI4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Mapping between SQL and Aggregation' chapter_name='Week 5 - Aggregation'>
<vertical>
<video display_name='Lecture' youtube='1.0:auL2R0XKlyM'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Some Common SQL examples' chapter_name='Week 5 - Aggregation'>
<vertical>
<video display_name='Lecture' youtube='1.0:ep2gLSR6C0U'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Limitations of the Aggregation Framwork' chapter_name='Week 5 - Aggregation'>
<vertical>
<video display_name='Lecture' youtube='1.0:8BQzKXI-_wE'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 5.1' chapter_name='Week 5 - Aggregation' format='Homework' due='Dec 5 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_5_1_problem' rerandomize='never' display_name='Homework: HW 5.1'>
<b>Finding the most frequent author of comments on your blog</b><br/>
In this assignment you will use the aggregation framework to find the most frequent author of comments on your blog. We will be using the same dataset as last week.
<br/><br/>
Start by downloading the posts.json dataset from last week's homework, found in <a href="/static/handouts/hw4-3.tar">hw4-3.tar</a> or <a href="/static/handouts/hw4-3.zip">hw4-3.zip</a>.  Then import into your blog database as follows:
<pre>
mongoimport -d blog -c posts --drop &lt; posts.json
</pre>
Now use the aggregation framework to calculate the author with the greatest number of comments.
<br/><br/>
To help you verify your work before submitting, the author with the least comments is Mariela Sherer and she commented 387 times.
<br/><br/>
Ok, please choose your answer below for the most prolific comment author:

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Gwyneth Garling</text></choice>
<choice location='bottom' correct='false'><text>Milan Mcgavock</text></choice>
<choice location='bottom' correct='true'><text>Elizabet Kleine</text></choice>
<choice location='bottom' correct='false'><text>Dusti Lemmond</text></choice>
<choice location='bottom' correct='false'><text>Leonida Lafond</text></choice>
<choice location='bottom' correct='false'><text>Corliss Zuk</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:9wkTlkRZ8Z0'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 5.2' chapter_name='Week 5 - Aggregation' format='Homework' due='Dec 5 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_5_2_problem' rerandomize='never' display_name='Homework: HW 5.2'>
<b>Crunching the Zipcode dataset</b><br/>
Please download the <a href="http://media.mongodb.org/zips.json">zips.json</a> dataset and import it into a collection of your choice. 
<br/>
<br/>
Please calculate the average population of cities in California (abbreviation CA)  and New York (NY) (taken together) with populations over 25,000.
<br/><br/>
For this problem, assume that a city name that appears in more than one state represents two separate cities. 
<br/><br/>
Please round the answer to a whole number. 
<br/>
Hint: The answer for CT and NJ is 49749.

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>78347</text></choice>
<choice location='bottom' correct='false'><text>96343</text></choice>
<choice location='bottom' correct='false'><text>86253</text></choice>
<choice location='bottom' correct='false'><text>93164</text></choice>
<choice location='bottom' correct='true'><text>82541</text></choice>
<choice location='bottom' correct='false'><text>68341</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:VTSFb8m4vrs'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 5.3' chapter_name='Week 5 - Aggregation' format='Homework' due='Dec 5 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_5_3_problem' rerandomize='never' display_name='Homework: HW 5.3'>
<b>Who's the easiest grader on campus?</b>
<br/>
In this problem you will be analyzing a dataset of student grades. Please import <a href="/static/handouts/grades_5-3.js">grades_5-3.js</a> into a database and collection of your choice. 
<br/><br/>
The documents look like this:
<pre>
{
	"_id" : ObjectId("50b59cd75bed76f46522c392"),
	"student_id" : 10,
	"class_id" : 5,
	"scores" : [
		{
			"type" : "exam",
			"score" : 69.17634380939022
		},
		{
			"type" : "quiz",
			"score" : 61.20182926719762
		},
		{
			"type" : "homework",
			"score" : 73.3293624199466
		},
		{
			"type" : "homework",
			"score" : 15.206314042622903
		},
		{
			"type" : "homework",
			"score" : 36.75297723087603
		},
		{
			"type" : "homework",
			"score" : 64.42913107330241
		}
	]
}
</pre>
There are documents for each student (student_id) across a variety of classes (class_id). Note that not all students in the same class have the same exact number of assessments. Some students have three homework assignments, etc. 
<br/>
<br/>
Your task is to calculate the class with the best average student performance. This involves calculating an average for each student in each class of all non-quiz assessments and then averaging those numbers to get a class average. To be clear, each student's average includes only exams and homework grades. <b>Don't include their quiz scores in the calculation.</b>
<br/><br/>
What is the class_id which has the highest average student perfomance?
<br/>
<br/>Hint/Strategy: You need to group twice to solve this problem. You must figure out the GPA that each student has achieved in a class and then average those numbers to get  a class average. After that, you just need to sort. The hardest class is class_id=2. Those students achieved a class average of 37.6
<br/><br/>
Below, choose the class_id with the highest average student average.
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>8</text></choice>
<choice location='bottom' correct='false'><text>9</text></choice>
<choice location='bottom' correct='true'><text>1</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
<choice location='bottom' correct='false'><text>7</text></choice>
<choice location='bottom' correct='false'><text>0</text></choice>
<choice location='bottom' correct='false'><text>6</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:wqfqAzhOie8'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 5.4' chapter_name='Week 5 - Aggregation' format='Homework' due='Dec 5 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_5_4_problem' rerandomize='never' display_name='Homework: HW 5.4'>
<b>Removing Rural Residents</b>
In this problem you will calculate the number of people who live in a zip code in the US where the city starts with a digit. We will take that to mean they don't really live in a city.  Once again, you will be using the zip code collection you imported earlier.
<br/><br/>
The project operator can extract the first digit from any field. For example, to extract the first digit from the city field, you could write this query:
<pre>
db.zips.aggregate([
    {$project: 
     {
	first_char: {$substr : ["$city",0,1]},
     }	 
])
</pre>
Using the aggregation framework, calculate the sum total of people who are living in a zip code where the city starts with a digit. Choose the answer below.
<br/><br/>
<i>Note that you will need to probably change your projection to send more info through than just that first character. Also, you will need a filtering step to get rid of all documents where the city does not start with a digital (0-9).</i>
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>298015</text></choice>
<choice location='bottom' correct='false'><text>345232</text></choice>
<choice location='bottom' correct='false'><text>245987</text></choice>
<choice location='bottom' correct='false'><text>312893</text></choice>
<choice location='bottom' correct='false'><text>158249</text></choice>
<choice location='bottom' correct='false'><text>543282</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:UpwIQjRO2vw'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-12-03T00:00' display_name='Week 6 - Application Engineering' hide_answer_status_until_due='False'>
<sequential graded='false' display_name='Introduction' chapter_name='Week 6 - Application Engineering'>
<vertical>
<video display_name='Lecture' youtube='1.0:3zcbhNHebAc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Write Concern' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:EtEPEkX3koo'/>
</vertical>
<problem showanswer='attempted' url_name='Write_Concern_problem' rerandomize='never' display_name='Quiz: Write Concern'>
Provided you assume that the disk is persistent, what are the w and j settings required to guarantee that an insert or update has been written all the way to disk. <multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>w=0, j=0</text></choice>
<choice location='bottom' correct='true'><text>w=1, j=1</text></choice>
<choice location='bottom' correct='false'><text>w=2, j=0</text></choice>
<choice location='bottom' correct='false'><text>w=1, j=0</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:2-UO105PDrk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Network Errors' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:BycNYXFpqhM'/>
</vertical>
<problem showanswer='attempted' url_name='Network_Errors_problem' rerandomize='never' display_name='Quiz: Network Errors'>
What are the reasons why an application may receive an error back even if the write was successful. Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>The network TCP network connection between the application and the server was reset between the time of the write and the time of the getLastError call.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The MongoDB server terminates between the write and the getLastError call.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The network fails between the time of the write and the time of the getLastError call<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The write violates a primary key constraint on the collection and must be rolled back.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:64mAA3SEnkg'/>
</vertical>
</sequential>
<sequential graded='false' display_name='The Pymongo Driver' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:H1zGLx8ggXk'/>
</vertical>
<problem showanswer='attempted' url_name='The_Pymongo_Driver_problem' rerandomize='never' display_name='Quiz: The Pymongo Driver'>
In the 2.4 release of Pymongo, a new connection class is introduced that automatically sets w=1, j=0. It essentially defaults to what used to be called safe mode and replaces the old Connection class. What is the name of that class?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>MongoSafe</text></choice>
<choice location='bottom' correct='false'><text>SafeConnection</text></choice>
<choice location='bottom' correct='true'><text>MongoClient</text></choice>
<choice location='bottom' correct='false'><text>FireAndRemember</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ghbQtF5YfHw'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Introduction to Replication' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:f1WTYGORU3w'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_Replication_problem' rerandomize='never' display_name='Quiz: Introduction to Replication'>
What is the minimum original number of nodes needed to assure the election of a new Primary if a node goes down? <multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>1</text></choice>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='true'><text>3</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:XCssKzhlnZU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Replica Set Elections' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:WFXSVHO78bQ'/>
</vertical>
<problem showanswer='attempted' url_name='Replica_Set_Elections_problem' rerandomize='never' display_name='Quiz: Replica Set Elections'>
Which types of nodes can participate in elections of a new primary?<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Regular replica set members<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Hidden Members<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Arbiters<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Lawyers<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vrUxTTD-XwA'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Write Consistency' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:Oqf_Eza-s1M'/>
</vertical>
<problem showanswer='attempted' url_name='Write_Consistency_problem' rerandomize='never' display_name='Quiz: Write Consistency'>
During the time when failover is occurring, can writes successfully complete?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Yes</text></choice>
<choice location='bottom' correct='true'><text>No</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:SjaJEYK1u3E'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Creating a Replica Set' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:flCFVFBRsKI'/>
</vertical>
<problem showanswer='attempted' url_name='Creating_a_Replica_Set_problem' rerandomize='never' display_name='Quiz: Creating a Replica Set'>
Which command, when issued from the mongo shell, will allow you to read from a secondary?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>db.isMaster()</text></choice>
<choice location='bottom' correct='false'><text>db.adminCommand({'readPreference':'Secondary"})</text></choice>
<choice location='bottom' correct='false'><text>rs.setStatus("Primary")</text></choice>
<choice location='bottom' correct='true'><text>rs.slaveOk()</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:ibZVf59aUj8'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Replica Set Internals' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:lx0Kj4n4EWM'/>
</vertical>
<problem showanswer='attempted' url_name='Replica_Set_Internals_problem' rerandomize='never' display_name='Quiz: Replica Set Internals'>
In the video how long did it take to elect a new primary?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>About three seconds</text></choice>
<choice location='bottom' correct='false'><text>Above 10 seconds</text></choice>
<choice location='bottom' correct='false'><text>About 30 seconds</text></choice>
<choice location='bottom' correct='false'><text>About a minute</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:_am2mdVF1uk'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Failover and Rollback' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:IW1oW_Adlt0'/>
</vertical>
<problem showanswer='attempted' url_name='Failover_and_Rollback_problem' rerandomize='never' display_name='Quiz: Failover and Rollback'>
What happens if a node comes back up as a secondary after a period of being offline and the oplog has looped on the primary?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>The entire dataset will be copied from the primary</text></choice>
<choice location='bottom' correct='false'><text>A rollback will occur</text></choice>
<choice location='bottom' correct='false'><text>The new node stays offline (does not re-join the replica set)</text></choice>
<choice location='bottom' correct='false'><text>The new node begins to calculate Pi to a large number of decimal places</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:t3rNxRg6WZE'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Connecting to a Replica Set from Pymongo' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:qjxOq5RFWlc'/>
</vertical>
<problem showanswer='attempted' url_name='Connecting_to_a_Replica_Set_from_Pymongo_problem' rerandomize='never' display_name='Quiz: Connecting to a Replica Set from Pymongo'>
If you leave a replica set node out of the seedlist within the driver, what will happen?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>The missing node will not be used by the application.</text></choice>
<choice location='bottom' correct='true'><text>The missing node will be discovered as long as you list at least one valid node.</text></choice>
<choice location='bottom' correct='false'><text>This missing node will be used for reads, but not for writes.</text></choice>
<choice location='bottom' correct='false'><text>The missing node will be used for writes, but not for reads.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:rODKm1GvUpY'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Bad Things Happen to Good Nodes' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ccWbkVVE5gE'/>
</vertical>
<problem showanswer='attempted' url_name='Bad_Things_Happen_to_Good_Nodes_problem' rerandomize='never' display_name='Quiz: Bad Things Happen to Good Nodes'>
If you use the special MongoReplicaSetClient, are you guaranteed to avoid a network error due an intervening failover?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Yes</text></choice>
<choice location='bottom' correct='true'><text>No</text></choice>
<choice location='bottom' correct='false'><text></text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:nHsd9EJsKDc'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Write Concern Revisited' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:5VyXyccjS3k'/>
<html>
<h2>Lecture Notes</h2>
To be clear, it is best practice to set w:majority to avoid having data rolled back in the case of a single node failure. Take the three node example. If you set w:majority, then at least one other node will have the date at the time of failover. That node will be preferred to take over as primary.  At 2:42 I suggested this would be the case, but said I was not certain. I investigated it further and confirmed that the node that is furthest ahead will be preferred in the election of a new primary.</html>
</vertical>
<problem showanswer='attempted' url_name='Write_Concern_Revisited_problem' rerandomize='never' display_name='Quiz: Write Concern Revisited'>
If you set w=1 and j=1, is it possible to wind up rolling back a committed write to the primary on failover?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>Yes</text></choice>
<choice location='bottom' correct='false'><text>No</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:hQrCwRplszo'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Read Preferences' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:_c8_YYln5WU'/>
</vertical>
<problem showanswer='attempted' url_name='Read_Preferences_problem' rerandomize='never' display_name='Quiz: Read Preferences'>
You can configure your applications via the drivers to read from secondary nodes within a replica set. What are the reasons that you might not want to do that? Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>If your write traffic is significantly greater than your read traffic,  you may overwhelm the secondary, which must process all the writes as well as the reads. Replication lag can result.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>You may not read what you previously wrote to MongoDB.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>If the secondary hardware has insufficient memory to keep the read working set in memory, directing reads to it will likely slow it down.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Reading from a secondary prevents it from being promoted to primary.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:tp17iqGdw-k'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Review Implications of Replication' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:K5ISnvYKQFQ'/>
</vertical>
<problem showanswer='attempted' url_name='Review_Implications_of_Replication_problem' rerandomize='never' display_name='Quiz: Review Implications of Replication'>
If you set w=4  on a connection and there are only three nodes in the replica set, how long will you wait in PyMongo for a response from an insert if you don't set a timeout?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Comes back immediately</text></choice>
<choice location='bottom' correct='false'><text>About a minute</text></choice>
<choice location='bottom' correct='false'><text>About 10 seconds</text></choice>
<choice location='bottom' correct='true'><text>More than five minutes</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:8wuWShep8Qs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Introduction to Sharding' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:_GfDqa1qRl0'/>
</vertical>
<problem showanswer='attempted' url_name='Introduction_to_Sharding_problem' rerandomize='never' display_name='Quiz: Introduction to Sharding'>
If the shard key is not include in a find operation and there are 3 shards, each one a replica set with 3 nodes, how many nodes will see the find operation?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>1</text></choice>
<choice location='bottom' correct='true'><text>3</text></choice>
<choice location='bottom' correct='false'><text>9</text></choice>
<choice location='bottom' correct='false'><text>6</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:4Z0D2bX5Cg4'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Building a Sharded Environment' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:aaYc2W4keF4'/>
</vertical>
<problem showanswer='attempted' url_name='Building_a_Sharded_Environment_problem' rerandomize='never' display_name='Quiz: Building a Sharded Environment'>
If you want to build a production system with two shards, each one a replica set with three nodes, how may mongod processes must you start?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>2</text></choice>
<choice location='bottom' correct='false'><text>6</text></choice>
<choice location='bottom' correct='false'><text>7</text></choice>
<choice location='bottom' correct='true'><text>9</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:5tPjnJrY0rU'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Implications of Sharding' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:ig278F60gRA'/>
</vertical>
<problem showanswer='attempted' url_name='Implications_of_Sharding_problem' rerandomize='never' display_name='Quiz: Implications of Sharding'>
Suppose you wanted to shard the zip code collection after importing it.  You want to shard on zip code. What index would be required to allow MongoDB to shard on zip code? <multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>An index on zip or a non-multi-key index that starts with zip.</text></choice>
<choice location='bottom' correct='false'><text>No index is required to use zip as the shard key.</text></choice>
<choice location='bottom' correct='false'><text>A unique index on the zip code.</text></choice>
<choice location='bottom' correct='false'><text>Any index that that includes the zip code.</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:vfl0hqdgB3Q'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Sharding + Replication' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:gkUCUbM0oEg'/>
</vertical>
<problem showanswer='attempted' url_name='Sharding_Replication_problem' rerandomize='never' display_name='Quiz: Sharding + Replication'>
Suppose you want to run multiple mongos routers for redundancy. What level of the stack will assure that you can failover to a different mongos from within your application?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>mongod</text></choice>
<choice location='bottom' correct='false'><text>mongos</text></choice>
<choice location='bottom' correct='true'><text>drivers</text></choice>
<choice location='bottom' correct='false'><text>sharding config servers</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:hnuiYokdO7g'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Choosing a Shard Key' chapter_name='Week 6 - Application Engineering' format='Quiz'>
<vertical>
<video display_name='Lecture' youtube='1.0:8q2GB3QSBSI'/>
</vertical>
<problem showanswer='attempted' url_name='Choosing_a_Shard_Key_problem' rerandomize='never' display_name='Quiz: Choosing a Shard Key'>
You are building a facebook competitor called footbook that will be a mobile social network of feet.  You have decided that your primary data structure for posts to the wall will look like this:
<pre>
{'username':'toeguy',
     'posttime':ISODate("2012-12-02T23:12:23Z"),
     "randomthought": "I am looking at my feet right now",
     'visible_to':['friends','family', 'walkers']}
</pre>
Thinking about the tradeoffs of shard key selection, select the true statements below.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>Choosing posttime as the shard key  will cause hotspotting as time progresses.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Choosing username as the shard key will distribute posts to the wall well across the shards.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Choosing visible_to as a shard key is illegal.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Choosing posttime as the shard key suffers from low cardinality.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:91tO_iGga5w'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 6.1' chapter_name='Week 6 - Application Engineering' format='Homework' due='Dec 11 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_6_1_problem' rerandomize='never' display_name='Homework: HW 6.1'>
Which of the following statements are true about MongoDB replication.  Check all that apply.<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>The minimum sensible number of voting nodes to a replica set is three.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>MongoDB replication is synchronous.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The Mongo shell is capable of attaching to a replica set and automatically failing over.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>By default, using the new MongoClient connection class, w=1 and j=1.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The oplog utilizes a capped collection.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:J4ZuF8UJD9s'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 6.2' chapter_name='Week 6 - Application Engineering' format='Homework' due='Dec 11 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_6_2_problem' rerandomize='never' display_name='Homework: HW 6.2'>
Let's suppose you have a five member replica set and want to assure that writes are committed to the journal and are acknowledged by at least 3 nodes before you proceed forward. What would be the appropriate settings for w and j?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>w=1, j=1</text></choice>
<choice location='bottom' correct='true'><text>w="majority", j=1</text></choice>
<choice location='bottom' correct='false'><text>w=3, j=0</text></choice>
<choice location='bottom' correct='false'><text>w=5, j=1</text></choice>
<choice location='bottom' correct='false'><text>w=1,j=3</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:8K-6JPrvkEs'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 6.3' chapter_name='Week 6 - Application Engineering' format='Homework' due='Dec 11 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_6_3_problem' rerandomize='never' display_name='Homework: HW 6.3'>
Which of the following statements are true about choosing and using a shard key: <choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>The shard key must be unique<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>There must be a index on the collection that starts with the shard key.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Mongo can not enforce unique indexes on a sharded collection other than the shard key itself.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Any update that does not contain the shard key will be sent to all shards.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>You can change the shard key on a collection if you desire.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:496QtQt4tX8'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 6.4' chapter_name='Week 6 - Application Engineering' format='Homework' due='Dec 11 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_6_4_problem' rerandomize='never' display_name='Homework: HW 6.4'>
You have a sharded system with three shards and have sharded the collections "grades" in the "test" database across those shards. The output of sh.status() when connected to mongos looks like this:

<pre>
mongos> sh.status()
--- Sharding Status --- 
  sharding version: { "_id" : 1, "version" : 3 }
  shards:
	{  "_id" : "s0",  "host" : "s0/localhost:37017,localhost:37018,localhost:37019" }
	{  "_id" : "s1",  "host" : "s1/localhost:47017,localhost:47018,localhost:47019" }
	{  "_id" : "s2",  "host" : "s2/localhost:57017,localhost:57018,localhost:57019" }
  databases:
	{  "_id" : "admin",  "partitioned" : false,  "primary" : "config" }
	{  "_id" : "test",  "partitioned" : true,  "primary" : "s0" }
		test.grades chunks:
				s1	4
				s0	4
				s2	4
			{ "student_id" : { $minKey : 1 } } -->> { "student_id" : 0 } on : s1 Timestamp(12000, 0) 
			{ "student_id" : 0 } -->> { "student_id" : 2640 } on : s0 Timestamp(11000, 1) 
			{ "student_id" : 2640 } -->> { "student_id" : 91918 } on : s1 Timestamp(10000, 1) 
			{ "student_id" : 91918 } -->> { "student_id" : 176201 } on : s0 Timestamp(4000, 2) 
			{ "student_id" : 176201 } -->> { "student_id" : 256639 } on : s2 Timestamp(12000, 1) 
			{ "student_id" : 256639 } -->> { "student_id" : 344351 } on : s2 Timestamp(6000, 2) 
			{ "student_id" : 344351 } -->> { "student_id" : 424983 } on : s0 Timestamp(7000, 2) 
			{ "student_id" : 424983 } -->> { "student_id" : 509266 } on : s1 Timestamp(8000, 2) 
			{ "student_id" : 509266 } -->> { "student_id" : 596849 } on : s1 Timestamp(9000, 2) 
			{ "student_id" : 596849 } -->> { "student_id" : 772260 } on : s0 Timestamp(10000, 2) 
			{ "student_id" : 772260 } -->> { "student_id" : 945802 } on : s2 Timestamp(11000, 2) 
			{ "student_id" : 945802 } -->> { "student_id" : { $maxKey : 1 } } on : s2 Timestamp(11000, 3) 
</pre>

If you ran the query 
<pre>
use test
db.grades.find({'student_id':530289})
</pre>
Which shards would be involved in answering the query?<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>s0,s1 and s2</text></choice>
<choice location='bottom' correct='false'><text>s0</text></choice>
<choice location='bottom' correct='true'><text>s1</text></choice>
<choice location='bottom' correct='false'><text>s2</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:uEemjO9S7vQ'/>
</vertical>
</sequential>
<sequential graded='true' display_name='HW 6.5' chapter_name='Week 6 - Application Engineering' format='Homework' due='Dec 11 23:00 EST 2012'>
<problem showanswer='due' attempts='3' url_name='HW_6_5_problem' rerandomize='never' display_name='Homework: HW 6.5'>
In this homework you will build a small replica set on your own computer.  We will check that it works with <i>validate.py</i>, which you should download in <a href="/static/handouts/week6-lessons.tar">week6-lessons.tar</a> or <a href="/static/handouts/week6-lessons.zip">week6-lessons.zip</a>. 
<br/><br/>
Create three directories for the three mongod processes. On unix, this could be done as follows:
<pre>
mkdir -p /data/rs1 /data/rs2 /data/rs3
</pre>
Now start three mongo instances as follows. Note that are three commands.  The browser is probably wrapping them visually.
<pre>
./mongod --replSet m101 --logpath "1.log" --dbpath /data/rs1 --port 27017 --smallfiles --fork

./mongod --replSet m101 --logpath "2.log" --dbpath /data/rs2 --port 27018 --smallfiles --fork

./mongod --replSet m101 --logpath "3.log" --dbpath /data/rs3 --port 27019 --smallfiles --fork
</pre>
Now connect to a mongo shell and make sure it comes up
<pre>
./mongo --port 27017
</pre>
Now you will create the replica set. Type the following commands into the mongo shell:
<pre>
config = { _id: "m101", members:[
          { _id : 0, host : "localhost:27017"},
          { _id : 1, host : "localhost:27018"},
          { _id : 2, host : "localhost:27019"} ]
};
rs.initiate(config);
</pre>
At this point, the replica set should be coming up. You can type 
<pre>
rs.status()
</pre>
to see the state of replication. 
<br/>
<br/>
Now run validate.py  to confirm that it works.
<pre>
python validate.py
</pre>
Validate connects to your local replica set and checks that it has three nodes. It has been tested under Pymongo 2.3 and 2.4. Type the validation code below.
<customresponse>
<textbox rows='4' cols='50' correct_answer="CongratsYouRock2012"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''CongratsYouRock2012'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
<vertical>
<video display_name='Answer' youtube='1.0:C0ZLyPfymR8'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-10-25T00:00' display_name='Week 7 - Case Studies'>
<sequential graded='false' display_name='Introduction' chapter_name='Week 7 - Case Studies'>
<vertical>
<video display_name='Lecture' youtube='1.0:adRyiudsgv0'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Interview with Jon Hoffman, foursquare' chapter_name='Week 7 - Case Studies'>
<vertical>
<video display_name='Lecture' youtube='1.0:GBauy0o-Wzs'/>
</vertical>
</sequential>
<sequential graded='false' display_name='Interview with Ryan Bubinski, Codecademy' chapter_name='Week 7 - Case Studies'>
<vertical>
<video display_name='Lecture' youtube='1.0:RkPmVQNesZA'/>
</vertical>
</sequential>
</chapter>
<chapter start='2012-10-25T00:00' display_name='Final Exam' hide_answer_status_until_due='True'>
<sequential graded='true' display_name='Question 1' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_1_problem' rerandomize='never' display_name='Final: Question 1'>
Please download the Enron email dataset <a href="/static/handouts/enron.tar">enron.tar</a> or <a href="/static/handouts/enron.zip">enron.zip</a>, untar or unzip it and then restore it using mongorestore. It should restore to a collection called "messages" in a database called "enron". Note that this is an abbreviated version of the full corpus. There should be 120,477 documents after restore.
<br/>
<br/>
Inspect a few of the documents to get a basic understanding of the structure. <a href="http://en.wikipedia.org/wiki/Enron">Enron</a> was an American corporation that engaged in a widespread accounting fraud and subsequently failed.
<br/>
<br/>
In this dataset, each document is an email message. Like all Email messages, there is one sender but there can be multiple recipients.
<br/>
<br/>
Construct a query to calculate the number of messages sent by Andrew Fastow, CFO, to Jeff Skilling, the president. Andrew Fastow's email addess was andrew.fastow@enron.com. Jeff Skilling's email was jeff.skilling@enron.com. 
<br/><br/>
For reference, the number of email messages from Andrew Fastow to John Lavorato (john.lavorato@enron.com) was 1.
<br/>

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>1</text></choice>
<choice location='bottom' correct='true'><text>3</text></choice>
<choice location='bottom' correct='false'><text>5</text></choice>
<choice location='bottom' correct='false'><text>7</text></choice>
<choice location='bottom' correct='false'><text>9</text></choice>
<choice location='bottom' correct='false'><text>12</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 2' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_2_problem' rerandomize='never' display_name='Final: Question 2'>
Please use the Enron dataset you imported for the previous problem. For this question you will use the aggregation framework to figure out pairs of people that tend to communicate a lot. 
<br/><br/>
Turns out that the top channel is veronica.espinoza@enron.com to recipients@enron.com, with 2181 messages. But that is not very interesting, so your task is to figure out the second most popular pair of sender and recipient and indicate it below.
<br/><br/>
Update: a few people have pointed out that a recipient sometimes appears more than once in the To header of a message. For our purposes, you can double count when that occurs. I did not consider it when designing the problem.
<br/><br/><multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>susan.mara@enron.com to jeff.dasovich@enron.com</text></choice>
<choice location='bottom' correct='true'><text>susan.mara@enron.com to richard.shapiro@enron.com</text></choice>
<choice location='bottom' correct='false'><text>soblander@carrfut.com to soblander@carrfut.com</text></choice>
<choice location='bottom' correct='false'><text>susan.mara@enron.com to james.steffes@enron.com</text></choice>
<choice location='bottom' correct='false'><text>evelyn.metoyer@enron.com to kate.symes@enron.com</text></choice>
<choice location='bottom' correct='false'><text>susan.mara@enron.com to alan.comnes@enron.com</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 3' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_3_problem' rerandomize='never' display_name='Final: Question 3'>
In this problem you will update a document in the Enron dataset to illustrate your mastery of updating documents from the shell.
<br/><br/>
Please add the email address "mrpotatohead@10gen.com" to the list of addresses in the "headers.To" array for the document with "headers.Message-ID" of "&lt;8147308.1075851042335.JavaMail.evans@thyme&gt;"
<br/><br/>
After you have completed that task, please run <a href="/static/handouts/final3-validate.py">final3-validate.py</a> to get the validation code and put it in the box below without any extra spaces. The validation script assumes that it is connecting to a simple mongo instance on the standard port on localhost.<customresponse>
<textbox rows='4' cols='50' correct_answer="897h6723ghf25gd87gh28"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''897h6723ghf25gd87gh28'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 4' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<vertical>
<video display_name='Lecture' youtube='1.0:E7-wlLWkP00'/>
</vertical>
<problem showanswer='due' url_name='Question_4_problem' rerandomize='never' display_name='Final: Question 4'>
<b>Enhancing the Blog to support viewers liking certain comments</b>
<br/>
In this problem, you will be enhancing the blog project to support users liking certain comments and the like counts showing up the in the permalink page. 
<br/>
<br/>
Start by downloading the code in <a href="/static/handouts/final-problem4.tar">final-problem4.tar</a> or <a href="/static/handouts/final-problem4.zip">final-problem4.zip</a> and loading up the blog dataset from last week. The user interface has already been implemented for you. It's not fancy. The /post URL shows the like counts next to each comment and displays a Like button that you can click on. That Like button POSTS to the /like URL on the blog, makes the necessary changes to the database state (you are implementing this), and then redirects the browser back to the permalink page. 
<br/><br/>
This full round trip and redisplay of the entire web page is not how you would implement liking in a modern web app, but it makes it easier for us to reason about, so we will go with it.
<br/><br/>
Your job is to search the code for the string "XXX work here" and make the necessary changes. You can choose whatever schema you want, but you should note that the entry_template makes some assumptions about the how the like value will be encoded and if you go with a different convention than it assumes, you will need to make some adjustments. 
<br/><br/>
It is possible to solve this problem by putting NOTHING in one of the XXX spots and adding only a SINGLE LINE to the other spot to properly increment the like count. If you decide to use a different schema than the entry_template is expecting, then you will likely to work in both spots. The validation script does not look at the database. It looks at the blog.
<br/>
<br/>
The validation script, final4-validate.py,  will fetch your blog, go to the first post's permalink page and attempt to increment the vote count. You run it as follows:
<pre>
python final4_validate.py
</pre>
Remember that the blog needs to be running as well as Mongo. The validation script takes some options if you want to run outside of localhost. 
<br/><br/>
After you have gotten it working, enter the validation string below.<customresponse>
<textbox rows='4' cols='50' correct_answer="89jlkfdsjflks34j0d"> </textbox>
<answer type='loncapa/python'><![CDATA[
import re
correct = ['correct']
try:
  r = str(submission[0])
except ValueError:
  correct[0] = 'incorrect'
  r = '0'
response = re.sub(r'\s+', '', r)
quiz_answer = '''89jlkfdsjflks34j0d'''
quiz_answer = re.sub(r'\s+', '', quiz_answer)
if not(response == quiz_answer):
  correct[0] = 'incorrect'
  print 'response = ', response
  print 'quiz_answer = ', quiz_answer
]]>
</answer>
</customresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 5' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_5_problem' rerandomize='never' display_name='Final: Question 5'>
Suppose your have a collection <i>fubar</i> with the following indexes created:
<pre>
[
	{
		"v" : 1,
		"key" : {
			"_id" : 1
		},
		"ns" : "test.fubar",
		"name" : "_id_"
	},
	{
		"v" : 1,
		"key" : {
			"a" : 1,
			"b" : 1
		},
		"ns" : "test.fubar",
		"name" : "a_1_b_1"
	},
	{
		"v" : 1,
		"key" : {
			"a" : 1,
			"c" : 1
		},
		"ns" : "test.fubar",
		"name" : "a_1_c_1"
	},
	{
		"v" : 1,
		"key" : {
			"c" : 1
		},
		"ns" : "test.fubar",
		"name" : "c_1"
	},
	{
		"v" : 1,
		"key" : {
			"a" : 1,
			"b" : 1,
			"c" : -1
		},
		"ns" : "test.fubar",
		"name" : "a_1_b_1_c_-1"
	}
]

</pre>

Now suppose you want to run the following query against the collection.
<pre>
db.fubar.find({'a':{'$lt':10000}, 'b':{'$gt': 5000}}, {'a':1, 'c':1}).sort({'c':-1})
</pre>
Which of the following indexes could be used by MongoDB to assist in answering the query. Check all that apply.
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>_id_<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>a_1_b_1<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>a_1_c_1<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>c_1<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>a_1_b_1_c_-1<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 6' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_6_problem' rerandomize='never' display_name='Final: Question 6'>
Suppose you have a collection of students of the following form:

<pre>
{
	"_id" : ObjectId("50c598f582094fb5f92efb96"),
	"first_name" : "John",
	"last_name" : "Doe",
	"date_of_admission" : ISODate("2010-02-21T05:00:00Z"),
	"residence_hall" : "Fairweather",
	"has_car" : true,
	"student_id" : "2348023902",
	"current_classes" : [
		"His343",
		"Math234",
		"Phy123",
		"Art232"
	]
}

</pre>


Now suppose that basic inserts into the collection, which only include the last name, first name and student_id, are too slow. What could potentially improve the speed of inserts. Check all that apply.
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='false'>
<startouttext/>Add an index on last_name, first_name if one does not already exist.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Set w=0, j=0 on writes<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>Remove all indexes from the collection<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Provide a hint to MongoDB that it should not use an index for the inserts<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>Build a replica set and insert data into the secondary nodes to free up the primary nodes.<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 7' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_7_problem' rerandomize='never' display_name='Final: Question 7'>
You have been tasked to cleanup a photosharing database. The database consists of two collections, albums, and images. Every image is supposed to be in an album, but there are orphan images that appear in no album.

 Here are some example documents (not from the collections you will be downloading).
<br/>
<br/>
<pre>
> db.albums.findOne()
{
	"_id" : 67
	"images" : [
		4745,
		7651,
		15247,
		17517,
		17853,
		20529,
		22640,
		27299,
		27997,
		32930,
		35591,
		48969,
		52901,
		57320,
		96342,
		99705
	]
}

> db.images.findOne()
{ "_id" : 99705, "height" : 480, "width" : 640 }
> 
</pre>
From the above, you can conclude that the image with _id = 99705 is in album 67. It is not an orphan.
<br/><br/>
Your task is to write a program to remove every image from the images collection that appears in no album. Or put another way, if an image does not appear in at least one album, it's an orphan and should be removed from the images collection.
<br/><br/>
Start by using mongoimport to import your <a href="/static/handouts/albums.json">albums.json</a> and <a href="/static/handouts/images.json">images.json</a> collections. (Did you notice the links in the previous sentence?)
<br/>
When you are done removing the orphan images from the collection, there should be 90,038 documents in the images collection. To prove you did it correctly, what is the sum of the _id fields from the images collection (you can get this by writing an aggregation query).
<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>4499664322</text></choice>
<choice location='bottom' correct='false'><text>4499664874</text></choice>
<choice location='bottom' correct='false'><text>4427664274</text></choice>
<choice location='bottom' correct='false'><text>3499619274</text></choice>
<choice location='bottom' correct='true'><text>4499664274</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 8' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_8_problem' rerandomize='never' display_name='Final: Question 8'>
Suppose you have a three node replica set. Node 1 is the primary. Node 2 is a secondary,  Node 3 is a secondary running with a delay of 10 seconds.  All writes to the database are issued with w=majority and j=1 (by which we mean that the getLastError call has those values set).

<br/><br/>A write operation (could be insert or update) is initiated from your application at time=0. At time=5 seconds, the primary, Node 1, goes down for an hour and another node is elected primary.
<br/><br/>Will there be a rollback of data when Node 1 comes back up? Choose the best answer.<br/>

<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='false'><text>Yes, always</text></choice>
<choice location='bottom' correct='false'><text>No, never</text></choice>
<choice location='bottom' correct='false'><text>Maybe, it depends on whether Node 3 has processed the write.</text></choice>
<choice location='bottom' correct='true'><text>Maybe, it depends only on whether Node 2 has processed the write. </text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 9' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_9_problem' rerandomize='never' display_name='Final: Question 9'>
Imagine an electronic medical record database designed to hold the medical records of every individual in the United States. Because each person has more than 16MB of medical history and records, it's not feasible to have a single document for every patient. Instead, there is a <i>patient</i> collection that contains basic information on each person and maps the person to a patient_id, and a <i>record</i> collection that contains one document for each test or procedure. One patient may have dozens or even hundreds of documents in the <i>record</i> collection. 
<br/><br/>
We need to decide on a shard key to shard the <i>record</i> collection. What's the best shard key for the <i>record</i> collection, provided that we are willing to run scatter gather operations to do research and run studies on various diseases and cohorts? That is, think mostly about the operational aspects of such a system.<multiplechoiceresponse direction='vertical'>
<choicegroup type='MultipleChoice'>
<choice location='bottom' correct='true'><text>patient_id</text></choice>
<choice location='bottom' correct='false'><text>_id</text></choice>
<choice location='bottom' correct='false'><text>primary care physican (your principal doctor)</text></choice>
<choice location='bottom' correct='false'><text>date and time when medical record was created</text></choice>
<choice location='bottom' correct='false'><text>patient first name</text></choice>
<choice location='bottom' correct='false'><text>patient last name</text></choice>
</choicegroup>
</multiplechoiceresponse>
</problem>
</sequential>
<sequential graded='true' display_name='Question 10' chapter_name='Final Exam' format='Final' due='Dec 17 23:00 EST 2012'>
<problem showanswer='due' url_name='Question_10_problem' rerandomize='never' display_name='Final: Question 10'>
<b>Understanding the output of explain</b>
We perform the following query on the enron dataset:
<pre>
db.messages.find({'headers.Date':{'$gt': new Date(2001,3,1)}},{'headers.From':1, _id:0}).sort({'headers.From':1}).explain()
</pre>
and get the following explain output. 
<pre>

{
	"cursor" : "BtreeCursor headers.From_1",
	"isMultiKey" : false,
	"n" : 83057,
	"nscannedObjects" : 120477,
	"nscanned" : 120477,
	"nscannedObjectsAllPlans" : 120581,
	"nscannedAllPlans" : 120581,
	"scanAndOrder" : false,
	"indexOnly" : false,
	"nYields" : 0,
	"nChunkSkips" : 0,
	"millis" : 250,
	"indexBounds" : {
		"headers.From" : [
			[
				{
					"$minElement" : 1
				},
				{
					"$maxElement" : 1
				}
			]
		]
	},
	"server" : "Andrews-iMac.local:27017"
}

</pre>
Check below all the statements that are true about the way MongoDB handled this query.
<choiceresponse direction='vertical'>
<checkboxgroup type='MultipleChoice'>
<choice correct='true'>
<startouttext/>The query did not utilize an index to figure out which documents match the find criteria.<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The query used an index for the sorting phase.<endouttext/>
</choice>
<choice correct='false'>
<startouttext/>The query returned 120,477 documents<endouttext/>
</choice>
<choice correct='true'>
<startouttext/>The query performed a full collection scan<endouttext/>
</choice>
</checkboxgroup>
</choiceresponse>
</problem>
</sequential>
</chapter>
</course>
